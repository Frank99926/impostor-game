<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>El Impostor</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0f0e17;
    --card: #1a1830;
    --card2: #221f3a;
    --accent1: #ff6b6b;
    --accent2: #ffd93d;
    --accent3: #6bcb77;
    --accent4: #4d96ff;
    --accent5: #c77dff;
    --text: #fffffe;
    --muted: #a7a9be;
    --border: rgba(255,255,255,0.08);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Nunito', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* BACKGROUND BLOBS */
  .bg-blobs {
    position: fixed; inset: 0; z-index: 0; pointer-events: none; overflow: hidden;
  }
  .blob {
    position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.15;
    animation: blobFloat 8s ease-in-out infinite;
  }
  .blob1 { width: 400px; height: 400px; background: var(--accent5); top: -100px; left: -100px; animation-delay: 0s; }
  .blob2 { width: 350px; height: 350px; background: var(--accent4); bottom: -100px; right: -100px; animation-delay: 3s; }
  .blob3 { width: 300px; height: 300px; background: var(--accent1); top: 40%; left: 40%; animation-delay: 1.5s; }

  @keyframes blobFloat {
    0%, 100% { transform: translate(0,0) scale(1); }
    50% { transform: translate(20px, -20px) scale(1.05); }
  }

  /* LAYOUT */
  #app {
    position: relative; z-index: 1;
    min-height: 100vh;
    display: flex; align-items: center; justify-content: center;
    padding: 20px;
  }

  .screen {
    display: none;
    width: 100%; max-width: 700px;
    animation: fadeIn 0.4s ease;
  }
  .screen.active { display: block; }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* CARD */
  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 24px;
    padding: 40px;
    backdrop-filter: blur(10px);
  }

  /* LOGO */
  .logo {
    font-family: 'Fredoka One', cursive;
    font-size: 3.5rem;
    text-align: center;
    margin-bottom: 8px;
    background: linear-gradient(135deg, var(--accent1), var(--accent2), var(--accent4));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: logoShine 3s ease-in-out infinite;
  }

  @keyframes logoShine {
    0%,100% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
  }

  .logo-sub {
    text-align: center;
    color: var(--muted);
    font-size: 1rem;
    margin-bottom: 36px;
    font-weight: 600;
    letter-spacing: 0.05em;
    text-transform: uppercase;
  }

  /* INPUTS */
  .input-group {
    margin-bottom: 16px;
  }
  label {
    display: block;
    font-size: 0.85rem;
    font-weight: 700;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 8px;
  }
  input, select {
    width: 100%;
    background: var(--card2);
    border: 2px solid var(--border);
    border-radius: 14px;
    padding: 14px 18px;
    color: var(--text);
    font-family: 'Nunito', sans-serif;
    font-size: 1rem;
    font-weight: 600;
    transition: border-color 0.2s, box-shadow 0.2s;
    outline: none;
  }
  input:focus, select:focus {
    border-color: var(--accent4);
    box-shadow: 0 0 0 4px rgba(77,150,255,0.15);
  }
  input::placeholder { color: var(--muted); font-weight: 400; }

  select option { background: #1a1830; }

  /* BUTTONS */
  .btn {
    width: 100%;
    padding: 16px 24px;
    border: none;
    border-radius: 14px;
    font-family: 'Fredoka One', cursive;
    font-size: 1.2rem;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s, filter 0.15s;
    letter-spacing: 0.02em;
  }
  .btn:hover { transform: translateY(-2px); filter: brightness(1.1); }
  .btn:active { transform: translateY(0); }

  .btn-primary {
    background: linear-gradient(135deg, var(--accent4), var(--accent5));
    color: white;
    box-shadow: 0 8px 30px rgba(77,150,255,0.3);
    margin-bottom: 12px;
  }
  .btn-secondary {
    background: linear-gradient(135deg, var(--accent1), #ff8e53);
    color: white;
    box-shadow: 0 8px 30px rgba(255,107,107,0.3);
    margin-bottom: 12px;
  }
  .btn-success {
    background: linear-gradient(135deg, var(--accent3), #52b788);
    color: white;
    box-shadow: 0 8px 30px rgba(107,203,119,0.3);
    margin-bottom: 12px;
  }
  .btn-warning {
    background: linear-gradient(135deg, var(--accent2), #ffb347);
    color: #1a1830;
    box-shadow: 0 8px 30px rgba(255,217,61,0.3);
    margin-bottom: 12px;
  }
  .btn-ghost {
    background: var(--card2);
    color: var(--muted);
    border: 2px solid var(--border);
    margin-bottom: 12px;
  }
  .btn-sm {
    width: auto;
    padding: 10px 20px;
    font-size: 1rem;
  }

  /* DIVIDER */
  .divider {
    display: flex; align-items: center; gap: 12px;
    margin: 20px 0;
    color: var(--muted); font-size: 0.85rem;
  }
  .divider::before, .divider::after {
    content: ''; flex: 1;
    height: 1px; background: var(--border);
  }

  /* PLAYERS LIST */
  .players-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 12px;
    margin: 20px 0;
  }
  .player-chip {
    background: var(--card2);
    border: 2px solid var(--border);
    border-radius: 14px;
    padding: 12px 8px;
    text-align: center;
    font-weight: 700;
    font-size: 0.85rem;
    position: relative;
    animation: chipIn 0.3s ease;
    overflow: hidden;
    word-break: break-word;
    max-width: 120px;
  }
  @keyframes chipIn {
    from { opacity: 0; transform: scale(0.8); }
    to { opacity: 1; transform: scale(1); }
  }
  .player-chip .avatar {
    font-size: 1.8rem; display: block; margin-bottom: 4px;
  }
  .player-chip .avatar-svg {
    width: 52px; height: 62px; display: block; margin: 0 auto 4px;
  }
  .player-chip .avatar-svg svg { width: 52px; height: 62px; }
  .player-chip.host { border-color: var(--accent2); }
  .player-chip.me { border-color: var(--accent4); }
  .player-chip.eliminated {
    opacity: 0.4;
    text-decoration: line-through;
  }

  /* ROLE REVEAL */
  .role-card {
    text-align: center;
    padding: 40px 20px;
  }
  .role-icon {
    font-size: 5rem;
    margin-bottom: 16px;
    animation: roleReveal 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    display: block;
  }
  @keyframes roleReveal {
    from { transform: scale(0) rotate(-20deg); opacity: 0; }
    to { transform: scale(1) rotate(0); opacity: 1; }
  }
  .role-title {
    font-family: 'Fredoka One', cursive;
    font-size: 2rem;
    margin-bottom: 8px;
  }
  .role-title.impostor { color: var(--accent1); }
  .role-title.player { color: var(--accent3); }

  .word-box {
    background: var(--card2);
    border: 3px solid var(--accent2);
    border-radius: 20px;
    padding: 24px;
    margin: 20px 0;
    animation: wordPop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s both;
  }
  @keyframes wordPop {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }
  .word-label {
    font-size: 0.8rem; font-weight: 700; color: var(--muted);
    text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 8px;
  }
  .word-value {
    font-family: 'Fredoka One', cursive;
    font-size: 2.5rem;
    color: var(--accent2);
  }

  /* TIMER */
  .timer-ring {
    position: relative;
    width: 120px; height: 120px;
    margin: 0 auto 20px;
  }
  .timer-ring svg { transform: rotate(-90deg); }
  .timer-ring circle {
    fill: none; stroke-width: 8;
    stroke-linecap: round;
    transition: stroke-dashoffset 1s linear, stroke 0.5s;
  }
  .timer-ring .bg { stroke: var(--card2); }
  .timer-ring .fg { stroke: var(--accent3); stroke-dasharray: 314; stroke-dashoffset: 0; }
  .timer-text {
    position: absolute; inset: 0;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Fredoka One', cursive;
    font-size: 2rem;
    color: var(--text);
  }

  /* CLUE INPUT */
  .clue-area {
    margin: 20px 0;
  }
  .clue-input-wrap {
    display: flex; gap: 10px;
  }
  .clue-input-wrap input {
    flex: 1;
  }
  .clue-input-wrap .btn {
    width: auto; padding: 14px 24px;
    font-size: 1rem; margin: 0;
  }

  /* CLUES LIST */
  .clues-list {
    margin: 20px 0;
  }
  .clue-item {
    background: var(--card2);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 14px 18px;
    margin-bottom: 10px;
    display: flex; align-items: center; gap: 14px;
    animation: clueIn 0.3s ease;
  }
  @keyframes clueIn {
    from { opacity: 0; transform: translateX(-10px); }
    to { opacity: 1; transform: translateX(0); }
  }
  .clue-item .clue-avatar { font-size: 1.5rem; }
  .clue-item .clue-name { font-weight: 700; font-size: 0.9rem; color: var(--muted); }
  .clue-item .clue-text { font-weight: 800; font-size: 1.05rem; }
  .clue-item.typing .clue-text { color: var(--accent4); font-style: italic; }
  .clue-item.waiting .clue-text { color: var(--muted); font-style: italic; font-weight: 400; }
  .clue-item.done .clue-text { color: var(--accent3); }
  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0} }
  .clue-item.typing .clue-text::after {
    content: "|";
    color: var(--accent4);
    margin-left: 1px;
    animation: blink 0.6s infinite;
    font-weight: 400;
  }
  .clue-item.pending { opacity: 0.5; font-style: italic; }

  /* VOTING */
  .vote-list { margin: 20px 0; }
  .vote-item {
    background: var(--card2);
    border: 2px solid var(--border);
    border-radius: 14px;
    padding: 14px 18px;
    margin-bottom: 10px;
    cursor: pointer;
    display: flex; align-items: center; gap: 14px;
    transition: border-color 0.2s, background 0.2s, transform 0.15s;
    font-weight: 700;
    font-size: 1rem;
  }
  .vote-item:hover { border-color: var(--accent1); transform: translateX(4px); }
  .vote-item.selected { border-color: var(--accent1); background: rgba(255,107,107,0.1); }
  .vote-item.eliminated { opacity: 0.4; pointer-events: none; text-decoration: line-through; }
  .vote-item .vote-avatar { font-size: 1.5rem; }

  /* VOTE RESULTS */
  .vote-bar-wrap { margin-bottom: 14px; }
  .vote-bar-name { font-weight: 700; margin-bottom: 6px; display: flex; justify-content: space-between; }
  .vote-bar {
    height: 12px; background: var(--card2); border-radius: 999px; overflow: hidden;
  }
  .vote-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent1), var(--accent2));
    border-radius: 999px;
    transition: width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
  }

  /* WIN SCREEN */
  .win-screen { text-align: center; padding: 20px; }
  .win-icon {
    font-size: 5rem;
    animation: winBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    display: block; margin-bottom: 12px;
  }
  @keyframes winBounce {
    0% { transform: scale(0); }
    60% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }
  .win-title {
    font-family: 'Fredoka One', cursive;
    font-size: 2.5rem;
    margin-bottom: 8px;
  }
  .confetti-item {
    position: fixed;
    width: 10px; height: 10px;
    border-radius: 2px;
    animation: confettiFall linear forwards;
    z-index: 100;
    pointer-events: none;
  }
  @keyframes confettiFall {
    0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
    100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
  }

  /* BADGE */
  .badge {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 999px;
    font-size: 0.8rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .badge-yellow { background: rgba(255,217,61,0.2); color: var(--accent2); }
  .badge-blue { background: rgba(77,150,255,0.2); color: var(--accent4); }
  .badge-red { background: rgba(255,107,107,0.2); color: var(--accent1); }
  .badge-green { background: rgba(107,203,119,0.2); color: var(--accent3); }

  /* INFO BOX */
  .info-box {
    background: var(--card2);
    border-left: 4px solid var(--accent4);
    border-radius: 0 14px 14px 0;
    padding: 16px 20px;
    margin: 16px 0;
    font-size: 0.9rem;
    color: var(--muted);
    font-weight: 600;
  }
  .info-box.warning { border-color: var(--accent2); }
  .info-box.danger { border-color: var(--accent1); }
  .info-box.success { border-color: var(--accent3); }

  /* SECTION TITLE */
  .section-title {
    font-family: 'Fredoka One', cursive;
    font-size: 1.5rem;
    margin-bottom: 16px;
    display: flex; align-items: center; gap: 10px;
  }

  /* STATUS */
  .status-dot {
    width: 8px; height: 8px; border-radius: 50%;
    display: inline-block; margin-right: 6px;
    animation: pulse 1.5s ease-in-out infinite;
  }
  .status-dot.green { background: var(--accent3); }
  .status-dot.yellow { background: var(--accent2); }
  @keyframes pulse {
    0%,100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.5; transform: scale(1.3); }
  }

  /* WAITING */
  .waiting-dots span {
    animation: dot 1.4s infinite;
    opacity: 0;
  }
  .waiting-dots span:nth-child(1) { animation-delay: 0s; }
  .waiting-dots span:nth-child(2) { animation-delay: 0.2s; }
  .waiting-dots span:nth-child(3) { animation-delay: 0.4s; }
  @keyframes dot { 0%,80%,100% { opacity: 0; } 40% { opacity: 1; } }

  /* ROUND BADGE */
  .round-indicator {
    text-align: center;
    margin-bottom: 24px;
  }

  /* CATEGORY TAG */
  .category-tag {
    display: inline-flex; align-items: center; gap: 6px;
    background: rgba(199,125,255,0.15);
    border: 1px solid rgba(199,125,255,0.3);
    color: var(--accent5);
    padding: 6px 14px;
    border-radius: 999px;
    font-size: 0.85rem;
    font-weight: 700;
  }

  .flex { display: flex; }
  .flex-between { display: flex; justify-content: space-between; align-items: center; }
  .gap-2 { gap: 8px; }
  .mb-2 { margin-bottom: 8px; }
  .mb-4 { margin-bottom: 16px; }
  .text-center { text-align: center; }
  .text-muted { color: var(--muted); font-size: 0.9rem; }
  .mt-4 { margin-top: 16px; }

  /* SCROLLBAR */
  .bg-blobs { display: none; }
  #bg-canvas { position: fixed; inset: 0; z-index: 0; pointer-events: none; }

  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: var(--card); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  /* HIDDEN ROLE (impostor sees ???) */
  .blurred-word {
    filter: blur(8px);
    user-select: none;
    cursor: pointer;
    transition: filter 0.3s;
  }
  .blurred-word:hover { filter: blur(0); }

  /* SPLASH SCREEN */
  #splash {
    position: fixed; inset: 0; z-index: 999;
    background: var(--bg);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    cursor: pointer;
    transition: opacity 0.5s ease, transform 0.5s ease;
  }
  #splash.hiding {
    opacity: 0; pointer-events: none; transform: scale(1.05);
  }
  .splash-logo {
    font-family: 'Fredoka One', cursive;
    font-size: 4rem;
    background: linear-gradient(135deg, var(--accent1), var(--accent2), var(--accent4));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    animation: splashLogoIn 0.7s cubic-bezier(0.34,1.56,0.64,1) 0.3s both;
  }
  @keyframes splashLogoIn {
    from { transform: scale(0.3) rotate(-10deg); opacity: 0; }
    to { transform: scale(1) rotate(0); opacity: 1; }
  }
  .splash-sub {
    color: var(--muted); font-size: 1rem; font-weight: 700; letter-spacing: 0.15em;
    text-transform: uppercase; margin-top: 8px;
    animation: fadeIn 0.5s ease 1s both;
  }
  .splash-click {
    margin-top: 40px;
    font-family: 'Fredoka One', cursive;
    font-size: 1.1rem;
    color: var(--accent2);
    letter-spacing: 0.1em;
    animation: splashPulse 1.4s ease-in-out infinite 1.5s both;
  }
  @keyframes splashPulse {
    0%,100% { opacity: 0.5; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.05); }
  }
  .splash-dots {
    display: flex; gap: 8px; margin-top: 20px;
    animation: fadeIn 0.5s ease 1.2s both;
  }
  .splash-dot {
    width: 10px; height: 10px; border-radius: 50%;
    animation: splashDotBounce 0.6s ease infinite alternate;
  }
  .splash-dot:nth-child(1) { background: var(--accent1); animation-delay: 0s; }
  .splash-dot:nth-child(2) { background: var(--accent2); animation-delay: 0.15s; }
  .splash-dot:nth-child(3) { background: var(--accent4); animation-delay: 0.3s; }
  @keyframes splashDotBounce {
    from { transform: translateY(0); }
    to { transform: translateY(-12px); }
  }

  /* ROLE REVEAL DRAMA */
  .role-dramatic-enter {
    animation: dramaticReveal 0.8s cubic-bezier(0.34,1.56,0.64,1) both;
  }
  @keyframes dramaticReveal {
    0% { transform: scale(0.5) translateY(30px); opacity: 0; filter: blur(10px); }
    100% { transform: scale(1) translateY(0); opacity: 1; filter: blur(0); }
  }
  .role-icon-impostor {
    animation: impostorPulse 1.5s ease-in-out infinite 0.8s;
  }
  @keyframes impostorPulse {
    0%,100% { filter: drop-shadow(0 0 0px var(--accent1)); }
    50% { filter: drop-shadow(0 0 20px var(--accent1)); }
  }
  .role-icon-player {
    animation: playerGlow 1.5s ease-in-out infinite 0.8s;
  }
  @keyframes playerGlow {
    0%,100% { filter: drop-shadow(0 0 0px var(--accent3)); }
    50% { filter: drop-shadow(0 0 20px var(--accent3)); }
  }

  /* VOTE RESULT DRAMA */
  .result-dramatic {
    animation: resultSlide 0.6s cubic-bezier(0.34,1.56,0.64,1) both;
  }
  @keyframes resultSlide {
    from { transform: translateY(40px) scale(0.8); opacity: 0; }
    to { transform: translateY(0) scale(1); opacity: 1; }
  }

  /* SCREEN TRANSITION */
  .screen.active {
    animation: screenEnter 0.35s cubic-bezier(0.25,0.46,0.45,0.94) both;
  }
  @keyframes screenEnter {
    from { opacity: 0; transform: translateY(24px) scale(0.98); }
    to { opacity: 1; transform: translateY(0) scale(1); }
  }

  /* WORD REVEAL FLASH */
  @keyframes wordFlash {
    0% { transform: scale(1.3); color: white; }
    100% { transform: scale(1); }
  }
  .word-flash { animation: wordFlash 0.4s ease both; }


    .card { padding: 24px 20px; }
    .logo { font-size: 2.5rem; }
    .players-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
  }

  /* ==================== AVATAR CREATOR ==================== */
  #screen-avatar .card { max-width: 520px; padding: 24px; }
  .avatar-preview-wrap {
    display: flex; flex-direction: column; align-items: center;
    margin: 12px 0 20px; gap: 0;
  }
  .avatar-svg-wrap {
    width: 150px; height: 180px; display: block; flex-shrink: 0;
    filter: drop-shadow(0 8px 24px rgba(0,0,0,0.5));
    transition: transform 0.3s cubic-bezier(0.34,1.56,0.64,1);
    overflow: visible;
  }
  .avatar-svg-wrap svg { width: 150px; height: 180px; display: block; }
  .avatar-svg-wrap:hover { transform: scale(1.06); }
  .avatar-name-preview {
    margin-top: 12px; font-family: "Fredoka One", cursive;
    font-size: 1.3rem; color: var(--accent2);
    letter-spacing: 0.04em; text-align: center;
  }
  .avatar-tabs {
    display: flex; gap: 6px; margin-bottom: 16px; flex-wrap: wrap;
  }
  .avatar-tab {
    flex: 1; min-width: 60px; padding: 8px 4px;
    background: var(--card2); border: 2px solid transparent;
    border-radius: 10px; cursor: pointer; text-align: center;
    font-size: 0.75rem; font-weight: 700; color: var(--muted);
    transition: all 0.15s; font-family: "Nunito", sans-serif;
  }
  .avatar-tab.active {
    border-color: var(--accent4); color: var(--accent4);
    background: rgba(77,150,255,0.1);
  }
  .avatar-tab-icon { font-size: 1.1rem; display: block; margin-bottom: 2px; }
  .avatar-options-panel { min-height: 120px; }
  .avatar-options-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(52px, 1fr));
    gap: 8px; margin-bottom: 12px;
  }
  .avatar-opt {
    aspect-ratio: 1; border-radius: 12px;
    background: var(--card2); border: 2px solid transparent;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    font-size: 1.3rem; transition: all 0.15s;
    position: relative; overflow: hidden;
  }
  .avatar-opt:hover { transform: scale(1.08); border-color: var(--border); }
  .avatar-opt.selected { border-color: var(--accent4); background: rgba(77,150,255,0.15); }
  .avatar-opt.selected::after {
    content: "‚úì"; position: absolute; bottom: 2px; right: 4px;
    font-size: 0.6rem; color: var(--accent4); font-weight: 900;
  }
  .color-opt {
    width: 36px; height: 36px; border-radius: 50%;
    cursor: pointer; border: 3px solid transparent;
    transition: all 0.15s; flex-shrink: 0;
  }
  .color-opt.selected { border-color: white; transform: scale(1.2); }
  .colors-row { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; }
  .avatar-share-box {
    background: var(--card2); border-radius: 10px; padding: 12px;
    display: flex; gap: 8px; align-items: center; margin-top: 12px;
    border: 1px solid var(--border);
  }
  .avatar-share-box input {
    flex: 1; background: transparent; border: none; color: var(--muted);
    font-size: 0.75rem; font-family: monospace; outline: none;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
</style>
  <!-- Firebase Realtime Database SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-database-compat.js"></script>
  <script>
    firebase.initializeApp({ databaseURL: "https://impostor-8a559-default-rtdb.firebaseio.com" });
    const db = firebase.database();
  </script>
</head>
<body>

<canvas id="bg-canvas"></canvas>

<div id="splash" onclick="dismissSplash()">
  <div class="splash-logo">üïµÔ∏è El Impostor</div>
  <div class="splash-sub">¬øPod√©s descubrirlo?</div>
  <div class="splash-dots">
    <div class="splash-dot"></div>
    <div class="splash-dot"></div>
    <div class="splash-dot"></div>
  </div>
  <div class="splash-click">‚ñ∂ TOC√Å PARA ENTRAR</div>
</div>

<div class="bg-blobs">
  <div class="blob blob1"></div>
  <div class="blob blob2"></div>
  <div class="blob blob3"></div>
</div>

<div id="app">
  <button id="btn-mute" onclick="toggleMute()" style="
    position:fixed; top:16px; right:16px; z-index:100;
    background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.15);
    border-radius:50%; width:42px; height:42px; font-size:1.1rem;
    cursor:pointer; transition:background 0.2s; color:white;
  " title="Silenciar m√∫sica">üîä</button>

  <!-- SCREEN: HOME -->
  <div class="screen active" id="screen-home">
    <div class="card">
      <div class="logo">üïµÔ∏è El Impostor</div>
      <div class="logo-sub">¬øPod√©s descubrirlo?</div>

      <div class="input-group">
        <label>Nombre de la sala (visible para todos)</label>
        <input type="text" id="input-name" placeholder="Ej: Messi, Sala de Juli..." maxlength="20" autocomplete="off">
      </div>

      <button class="btn btn-primary" onclick="createRoom()">‚ú® Crear sala</button>

      <div class="divider">o</div>

      <div class="input-group">
        <label>C√≥digo de sala</label>
        <input type="text" id="input-code" placeholder="ABCD" maxlength="6" style="text-transform:uppercase; letter-spacing: 0.2em; font-size:1.3rem; text-align:center;" autocomplete="off">
      </div>
      <button class="btn btn-secondary" onclick="joinRoom()">üöÄ Unirse a la sala</button>

      <div class="divider">o</div>
      <div class="input-group">
        <label>ü§ñ Cantidad de bots (modo test)</label>
        <select id="select-bots" style="margin-bottom:8px;">
          <option value="1">1 Bot</option>
          <option value="2" selected>2 Bots</option>
          <option value="3">3 Bots</option>
          <option value="4">4 Bots</option>
          <option value="5">5 Bots</option>
        </select>
      </div>
      <button class="btn btn-ghost" onclick="startSoloTest()" style="border-color:var(--accent5); color:var(--accent5);">üß™ Probar solo (modo test)</button>

      <div class="divider">o</div>
      <button class="btn btn-ghost" onclick="openAvatarCreator()" style="border-color:var(--accent1); color:var(--accent1);">üé® Crear mi personaje</button>

      <div class="info-box mt-4">
        <strong>¬øC√≥mo jugar?</strong><br>
        El sistema elige una palabra secreta. Los impostores <em>no la saben</em>. Todos dan pistas y al final votan qui√©n es el impostor.
      </div>

      <!-- BARRA DE M√öSICA -->
      <div id="music-bar" style="margin-top:14px; background:var(--card2); border-radius:12px; padding:10px 14px; display:flex; align-items:center; gap:10px; border:1px solid var(--border);">
        <button id="music-play-btn" onclick="toggleMusic()" style="background:none;border:none;cursor:pointer;font-size:1.4rem;padding:0;line-height:1;flex-shrink:0;">‚ñ∂Ô∏è</button>
        <div id="music-title" style="flex:1;font-size:0.8rem;color:var(--muted);">üéµ M√∫sica</div>
        <button onclick="randomSong()" style="background:none;border:none;cursor:pointer;font-size:0.78rem;color:var(--accent4);font-weight:700;padding:4px 10px;border-radius:6px;border:1px solid var(--accent4);white-space:nowrap;">üé≤ Random</button>
        <input type="range" id="music-volume" min="0" max="100" value="70" oninput="setMusicVolume(this.value)" style="width:65px;accent-color:var(--accent4);" title="Volumen">
      </div>
      <iframe id="yt-iframe" width="1" height="1" frameborder="0" style="position:fixed;top:-9999px;left:-9999px;" allow="autoplay; encrypted-media" allowfullscreen></iframe>

    </div>
  </div>

  <!-- SCREEN: AVATAR CREATOR -->
  <div class="screen" id="screen-avatar">
    <div class="card">
      <div class="flex-between mb-4">
        <div class="section-title">üé® Mi Personaje</div>
        <button class="btn btn-ghost btn-sm" onclick="saveAndGoHome()" style="margin:0; padding:8px 14px; font-size:0.85rem;">‚Üê Volver</button>
      </div>

      <!-- Name input inside avatar screen -->
      <div class="input-group" style="margin-bottom:12px;">
        <label>Tu nombre de usuario</label>
        <input type="text" id="avatar-username" placeholder="Ej: Mati, Juli, Gonza..." maxlength="20" autocomplete="off"
          oninput="onAvatarNameInput()" style="font-size:1.1rem; font-weight:700; text-align:center;">
      </div>

      <!-- Preview -->
      <div class="avatar-preview-wrap">
        <div class="avatar-svg-wrap">
          <svg id="avatar-preview-svg" viewBox="0 0 100 120" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
        <div class="avatar-name-preview" id="avatar-name-preview">Tu personaje</div>
      </div>

      <!-- Tabs -->
      <div class="avatar-tabs">
        <div class="avatar-tab active" onclick="switchTab('skin')" id="tab-skin">
          <span class="avatar-tab-icon">üé®</span>Piel
        </div>
        <div class="avatar-tab" onclick="switchTab('eyes')" id="tab-eyes">
          <span class="avatar-tab-icon">üëÅÔ∏è</span>Ojos
        </div>
        <div class="avatar-tab" onclick="switchTab('hair')" id="tab-hair">
          <span class="avatar-tab-icon">üíá</span>Pelo
        </div>
        <div class="avatar-tab" onclick="switchTab('accessory')" id="tab-accessory">
          <span class="avatar-tab-icon">üòé</span>Accesorio
        </div>
        <div class="avatar-tab" onclick="switchTab('outfit')" id="tab-outfit">
          <span class="avatar-tab-icon">üëï</span>Ropa
        </div>
      </div>

      <!-- Options panel -->
      <div class="avatar-options-panel" id="avatar-options-panel"></div>

      <!-- Auto-sync info -->
      <div class="info-box mt-4" style="text-align:center;">
        üîÑ Tu personaje se guarda en esta PC y aparece autom√°ticamente en el lobby cuando jug√°s
      </div>

      <button class="btn btn-success mt-4" onclick="saveAndGoHome()">‚úÖ Guardar personaje</button>
    </div>
  </div>

  <!-- SCREEN: LOBBY -->
  <div class="screen" id="screen-lobby">
    <div class="card">
      <div class="flex-between mb-4">
        <div class="section-title">üéÆ <span id="lobby-sala-name">Sala de espera</span></div>
        <div style="display:flex; gap:8px; align-items:center;">
          <span class="badge badge-blue" id="lobby-code-badge">----</span>
          <button class="btn btn-ghost btn-sm" onclick="leaveRoom()" style="margin:0; padding:8px 14px; font-size:0.85rem;">‚Üê Salir</button>
        </div>
      </div>

      <div class="info-box">
        Compart√≠ este c√≥digo con tus amigos: <strong id="lobby-code-display" style="font-size:1.4rem; color:var(--accent2); font-family:'Fredoka One',cursive; letter-spacing:0.15em;"></strong>
        <button class="btn btn-ghost btn-sm" style="margin-top:8px; margin-bottom:0;" onclick="copyCode()">üìã Copiar c√≥digo</button>
      </div>

      <div class="section-title mt-4">üë• Jugadores <span id="lobby-count" class="badge badge-green" style="font-size:0.9rem;">0/6</span></div>
      <div class="players-grid" id="lobby-players"></div>

      <div id="host-controls" style="display:none;">
        <div class="input-group mt-4">
          <label>üéÆ Modo de juego</label>
          <select id="select-gamemode">
            <option value="fixed">üîí Palabra fija ‚Äî misma palabra, pista nueva cada ronda</option>
            <option value="rotating">üîÑ Palabra nueva ‚Äî nueva palabra y pista cada ronda</option>
          </select>
        </div>
        <div class="input-group">
          <label>Cantidad de impostores</label>
          <select id="select-impostors">
            <option value="1">1 Impostor</option>
            <option value="2">2 Impostores</option>
          </select>
        </div>
        <div class="input-group">
          <label>Categor√≠a de palabras</label>
          <select id="select-category">
            <option value="random">üé≤ Aleatoria</option>
            <option value="futbol">‚öΩ F√∫tbol</option>
            <option value="cine">üé¨ Cine y Series</option>
            <option value="videojuegos">üéÆ Videojuegos</option>
            <option value="musica">üéµ M√∫sica</option>
            <option value="comida">üçï Comida</option>
            <option value="animales">üêæ Animales</option>
            <option value="tecnologia">üíª Tecnolog√≠a</option>
          </select>
        </div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:4px;">
          <button class="btn btn-ghost btn-sm" id="btn-add-bots" onclick="addBotsToRoom()" style="flex:0 0 auto;">ü§ñ Agregar bots</button>
          <button class="btn btn-success" onclick="startGame()" id="btn-start" style="flex:1;">‚ñ∂Ô∏è Iniciar juego</button>
        </div>
      </div>

      <div id="guest-waiting" style="display:none;">
        <div class="info-box warning text-center">
          <span class="status-dot yellow"></span>
          Esperando que el host inicie el juego<span class="waiting-dots"><span>.</span><span>.</span><span>.</span></span>
        </div>
      </div>

      <!-- CHAT EN TIEMPO REAL -->
      <div class="mt-4">
        <div class="section-title" style="font-size:0.9rem; margin-bottom:8px;">üí¨ Chat de sala</div>
        <div id="lobby-chat-messages" style="background:var(--card2); border-radius:10px; padding:10px; min-height:80px; max-height:160px; overflow-y:auto; margin-bottom:8px; font-size:0.85rem;"></div>
        <div style="display:flex; gap:8px;">
          <input type="text" id="chat-input" placeholder="Escrib√≠ algo..." maxlength="80" autocomplete="off"
            style="flex:1; padding:8px 12px; border-radius:8px; border:1px solid var(--border); background:var(--card2); color:var(--text); font-size:0.85rem;"
            onkeypress="if(event.key==='Enter') sendChatMessage()">
          <button class="btn btn-ghost btn-sm" onclick="sendChatMessage()" style="padding:8px 14px;">Enviar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- SCREEN: ROLE REVEAL -->
  <div class="screen" id="screen-role">
    <div class="card">
      <div class="flex-between mb-4">
        <span class="badge badge-blue" id="round-badge">Ronda 1</span>
        <button class="btn btn-ghost btn-sm" onclick="leaveRoom()" style="margin:0; padding:8px 14px; font-size:0.85rem;">‚Üê Salir</button>
      </div>

      <div class="role-card" id="role-reveal-content">
        <!-- filled dynamically -->
      </div>

      <div class="info-box">
        <strong>Consejo:</strong> No reveles tu rol. Si sos jugador, da pistas relacionadas con la palabra pero sin decirla directamente. Si sos impostor, ¬°trat√° de pasar desapercibido!
      </div>

      <button class="btn btn-primary" id="btn-ready" onclick="markReady()">¬°Entendido! üëç</button>

      <!-- Ready counter - always visible -->
      <div id="ready-counter" class="info-box text-center mt-4">
        <div style="display:flex; align-items:center; justify-content:center; gap:12px; flex-wrap:wrap;">
          <span>üë• Listos: <strong id="ready-count-text" style="color:var(--accent3);">0/0</strong></span>
          <span style="color:var(--muted);">|</span>
          <span>‚è≥ Arranca en: <strong id="ready-timer-text" style="color:var(--accent2);">30s</strong></span>
        </div>
      </div>
    </div>
  </div>

  <!-- SCREEN: CLUE PHASE -->
  <div class="screen" id="screen-clue">
    <div class="card">
      <div class="flex-between mb-4">
        <div class="section-title">üí¨ Ronda de pistas</div>
        <div class="timer-ring" id="timer-ring">
          <svg width="120" height="120" viewBox="0 0 120 120">
            <circle class="bg" cx="60" cy="60" r="50"/>
            <circle class="fg" id="timer-circle" cx="60" cy="60" r="50"/>
          </svg>
          <div class="timer-text" id="timer-text">60</div>
        </div>
      </div>

      <div class="flex-between mb-4">
        <div id="clue-category-tag"></div>
        <div id="my-word-reminder" style="font-size:0.85rem; color:var(--muted); font-weight:700;"></div>
      </div>

      <div class="clue-area" id="clue-input-area">
        <label>Tu pista</label>
        <div class="clue-input-wrap">
          <input type="text" id="input-clue" placeholder="Escribe una pista..." maxlength="30" autocomplete="off" onkeypress="if(event.key==='Enter') submitClue()" oninput="broadcastTyping()">
          <button class="btn btn-success" onclick="submitClue()" id="btn-submit-clue">Enviar ‚úâÔ∏è</button>
        </div>
      </div>

      <div id="clue-submitted-msg" style="display:none;">
        <div class="info-box success">
          ‚úÖ Pista enviada. Esperando a los dem√°s<span class="waiting-dots"><span>.</span><span>.</span><span>.</span></span>
        </div>
      </div>

      <div class="clues-list" id="clues-list"></div>
    </div>
  </div>

  <!-- SCREEN: VOTE -->
  <div class="screen" id="screen-vote">
    <div class="card">
      <div class="section-title">üó≥Ô∏è ¬°A votar!</div>
      <div class="info-box danger mb-4">
        Mir√° las pistas y decid√≠ qui√©n cre√©s que es el impostor. ¬°Ten√©s 30 segundos!
      </div>

      <div class="clues-list mb-4" id="vote-clues-summary"></div>

      <div class="vote-list" id="vote-list"></div>

      <div id="vote-timer-area" class="text-center mb-4">
        <span id="vote-timer-text" style="font-family:'Fredoka One',cursive; font-size:1.5rem; color:var(--accent2);"></span>
      </div>

      <button class="btn btn-warning" onclick="confirmVote()" id="btn-vote">Votar üéØ</button>
      <div id="vote-waiting" style="display:none;">
        <div class="info-box">
          <span class="status-dot green"></span>
          Voto registrado. Esperando a todos<span class="waiting-dots"><span>.</span><span>.</span><span>.</span></span>
        </div>
      </div>
    </div>
  </div>

  <!-- SCREEN: VOTE RESULTS -->
  <div class="screen" id="screen-vote-result">
    <div class="card">
      <div class="section-title text-center">üìä Resultados de votaci√≥n</div>
      <div id="vote-results-bars" class="mb-4"></div>
      <div id="elimination-result" class="text-center mb-4"></div>
      <button class="btn btn-primary" id="btn-next-round" onclick="nextRound()">Siguiente ronda ‚ñ∂Ô∏è</button>
      <div id="host-next-controls" style="display:none;"></div>
    </div>
  </div>

  <!-- SCREEN: WIN -->
  <div class="screen" id="screen-win">
    <div class="card win-screen">
      <span class="win-icon" id="win-icon">üèÜ</span>
      <div class="win-title" id="win-title">¬°Ganaron los jugadores!</div>
      <div class="text-muted mb-4" id="win-subtitle"></div>
      <div class="info-box" id="win-reveal"></div>
      <div style="display:flex;gap:12px;margin-top:16px;flex-wrap:wrap;justify-content:center;">
        <button class="btn btn-primary" onclick="backToLobby()">üîÑ Otra ronda</button>
        <button class="btn btn-ghost" onclick="leaveRoom()">üè† Ir al inicio</button>
      </div>
    </div>
  </div>

</div>

<script>
// ==================== GAME DATA ====================
const WORDS = {
  futbol: ['Messi', 'Ronaldo', 'Neymar', 'Mbapp√©', 'Pel√©', 'Maradona', 'Haaland', 'Benzema', 'Zidane', 'Beckham', 'Riquelme', 'Tevez', 'Su√°rez', 'Lewandowski', 'Iniesta', 'Xavi', 'Modric', 'Salah', 'De Bruyne', 'Vini Jr', 'Lamine Yamal', 'Pedri', 'Lautaro', 'Di Mar√≠a', 'Kun Ag√ºero'],
  cine: ['Avatar', 'Titanic', 'Joker', 'Matrix', 'Shrek', 'Narcos', 'El Juego del Calamar', 'Friends', 'Qui√©n es qui√©n', 'Los Vengadores', 'Batman', 'Interestelar', 'Coco', 'Arriba', 'Toy Story', 'Stranger Things', 'La Casa de Papel', 'El Rey Le√≥n', 'El Hombre Ara√±a', 'Harry Potter', 'Frozen', 'Los Minions', 'Parque Jur√°sico', 'El Padrino', 'Deadpool'],
  videojuegos: ['Minecraft', 'Fortnite', 'FIFA', 'Roblox', 'Mario', 'Zelda', 'Pok√©mon', 'GTA', 'Sonic', 'Halo', 'Los Sims', 'Tetris', 'Entre Nosotros', 'Valorant', 'Call of Duty', 'League of Legends', 'Clash Royale', 'Candy Crush', 'Elden Ring', 'Mortal Kombat', 'Street Fighter', 'Come-Cocos', 'Counter Strike', 'Diablo', 'Fall Guys'],
  musica: ['Shakira', 'Maluma', 'Ozuna', 'Bizarrap', 'Adele', 'Eminem', 'Beyonc√©', 'Drake', 'Rauw Alejandro', 'Karol G', 'Bad Bunny', 'Rosal√≠a', 'Daddy Yankee', 'Feid', 'Taylor Swift', 'The Weeknd', 'J Balvin', 'Nicki Nicole', 'Paulo Londra', 'Duki', 'Tini', 'Wos', 'Peso Pluma', 'Myke Towers', 'Anuel'],
  comida: ['Nutella', 'Doritos', 'Oreo', 'McDonald\'s', 'Subway', 'Starbucks', 'Pringles', 'Cheetos', 'Coca Cola', 'Pepsi', 'KFC', 'Burger King', 'Lays', 'Sprite', 'Red Bull', 'Monster', 'Milka', 'Toblerone', 'M&Ms', 'Skittles', 'Fanta', 'Seven Up', 'Heinz', 'Mentos', 'Trident'],
  animales: ['Simba', 'Dumbo', 'Bambi', 'Lassie', 'Nemo', 'Flipper', 'Pikachu', 'Hedwig', 'Chimuelo', 'Scooby Doo', 'Pumba', 'Tim√≥n', 'Plut√≥n', 'Balto', 'Bugs Bunny', 'Tom', 'Jerry', 'Garfield', 'Snoopy', 'Piol√≠n', 'Silvestre', 'El Pato Lucas', 'El Pato Donald', 'Goofy', 'Bolt'],
  tecnologia: ['Google', 'Apple', 'Samsung', 'Netflix', 'YouTube', 'Instagram', 'TikTok', 'Spotify', 'Tesla', 'Amazon', 'WhatsApp', 'Microsoft', 'Nvidia', 'Sony', 'Meta', 'Twitter', 'Snapchat', 'Discord', 'Twitch', 'Reddit', 'Pinterest', 'LinkedIn', 'Uber', 'Airbnb', 'PayPal']
};

const AVATARS = ['üê∫','ü¶ä','üê∏','üêº','ü¶Å','üêØ','üêª','ü¶ù','üê®','ü¶Ñ','üêô','ü¶à','ü¶ã','üê≤','ü¶Ö'];
const CATEGORY_NAMES = { futbol:'‚öΩ F√∫tbol', cine:'üé¨ Cine y Series', videojuegos:'üéÆ Videojuegos', musica:'üéµ M√∫sica', comida:'üçï Comida', animales:'üêæ Animales', tecnologia:'üíª Tecnolog√≠a' };

// ==================== STATE ====================
let state = {
  roomCode: null,
  myId: null,
  myName: null,
  myAvatar: null,
  isHost: false,
  players: {},       // id -> {name, avatar, eliminated}
  gameConfig: null,  // {impostors, category, word, impostorIds, round}
  myRole: null,      // 'impostor' | 'player'
  clues: {},         // id -> clue text
  votes: {},         // id -> voted-for-id
  timerInterval: null,
  timerValue: 60,
  voteTimerInterval: null,
  pollInterval: null,
  lastSyncHash: null,
  phase: 'lobby'     // lobby | role | clue | vote | result | win
};

// ==================== AUDIO SYSTEM (Web Audio API - sin archivos externos) ====================
let audioCtx = null;
let menuMusicInterval = null;
let menuMusicNodes = [];
let audioMuted = false; // declared here so playTone can use it

function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function playTone(freq, duration, type = 'sine', volume = 0.3, startTime = null) {
  if (audioMuted) return;
  try {
    const ctx = getAudioCtx();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.type = type;
    osc.frequency.value = freq;
    const t = startTime ?? ctx.currentTime;
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(volume, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, t + duration);
    osc.start(t);
    osc.stop(t + duration + 0.05);
  } catch(e) {}
}

function playChord(freqs, duration, type = 'sine', volume = 0.15) {
  freqs.forEach(f => playTone(f, duration, type, volume));
}

// UI click sound
function sfxClick() {
  playTone(880, 0.08, 'sine', 0.2);
}

// Join lobby / player enters
function sfxJoin() {
  playTone(523, 0.1, 'sine', 0.25);
  setTimeout(() => playTone(659, 0.1, 'sine', 0.25), 80);
  setTimeout(() => playTone(784, 0.15, 'sine', 0.25), 160);
}

// Countdown tick
function sfxTick() {
  playTone(440, 0.05, 'square', 0.08);
}

// Urgent tick (last 10 seconds)
function sfxTickUrgent() {
  playTone(660, 0.06, 'square', 0.15);
}

// Role reveal - impostor
function sfxImpostor() {
  try {
    const ctx = getAudioCtx();
    // Dramatic low sting
    [110, 116.5, 123.5].forEach((f, i) => {
      setTimeout(() => playTone(f, 0.6, 'sawtooth', 0.12), i * 120);
    });
    setTimeout(() => playTone(73.4, 1.2, 'sawtooth', 0.18), 400);
  } catch(e) {}
}

// Role reveal - player
function sfxPlayer() {
  // Uplifting arpeggio
  [523, 659, 784, 1047].forEach((f, i) => {
    setTimeout(() => playTone(f, 0.25, 'sine', 0.2), i * 100);
  });
}

// Clue submitted
function sfxClueSubmit() {
  playTone(784, 0.08, 'sine', 0.2);
  setTimeout(() => playTone(1047, 0.12, 'sine', 0.2), 80);
}

// Vote cast
function sfxVote() {
  playTone(440, 0.06, 'sine', 0.18);
  setTimeout(() => playTone(554, 0.12, 'sine', 0.18), 60);
}

// Vote results reveal
function sfxReveal() {
  const notes = [261, 329, 392, 523];
  notes.forEach((f, i) => setTimeout(() => playTone(f, 0.2, 'triangle', 0.2), i * 150));
}

// Caught impostor
function sfxCaught() {
  playTone(523, 0.1, 'sine', 0.25);
  setTimeout(() => playTone(659, 0.1, 'sine', 0.25), 100);
  setTimeout(() => playTone(784, 0.1, 'sine', 0.25), 200);
  setTimeout(() => playTone(1047, 0.4, 'sine', 0.3), 300);
}

// Impostor wins
function sfxImpostorWins() {
  [392, 370, 349, 330].forEach((f, i) => {
    setTimeout(() => playTone(f, 0.25, 'sawtooth', 0.15), i * 150);
  });
}

// Players win fanfare
function sfxWin() {
  const melody = [523, 659, 784, 659, 784, 1047];
  melody.forEach((f, i) => setTimeout(() => playTone(f, 0.18, 'sine', 0.22), i * 120));
}

// Timer end warning beeps
function sfxTimerEnd() {
  [880, 880, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.08, 'square', 0.2), i * 150));
}

// ---- MENU MUSIC ----
const MENU_MELODY = [
  { f: 523, d: 0.3 }, { f: 659, d: 0.3 }, { f: 784, d: 0.3 }, { f: 880, d: 0.6 },
  { f: 784, d: 0.3 }, { f: 659, d: 0.3 }, { f: 523, d: 0.6 },
  { f: 392, d: 0.3 }, { f: 523, d: 0.3 }, { f: 659, d: 0.3 }, { f: 784, d: 0.6 },
  { f: 659, d: 0.3 }, { f: 523, d: 0.3 }, { f: 392, d: 0.9 },
];
let menuMelodyIndex = 0;
let menuMusicTimer = null;
let menuMusicPlaying = false;

function startMenuMusic() { return; // replaced by YouTube player
  // (Web Audio menu music disabled)
}
function _disabledStartMenuMusic() {
  if (menuMusicPlaying) return;
  menuMusicPlaying = true;
  playMenuNote();
}

function playMenuNote() {
  if (!menuMusicPlaying) return;
  const note = MENU_MELODY[menuMelodyIndex % MENU_MELODY.length];
  playTone(note.f, note.d * 0.85, 'sine', 0.12);
  // bass note
  playTone(note.f / 2, note.d * 0.85, 'sine', 0.06);
  menuMelodyIndex++;
  menuMusicTimer = setTimeout(playMenuNote, note.d * 1000);
}

function stopMenuMusic() {
  menuMusicPlaying = false;
  // Also stop YouTube player
  const iframe = document.getElementById('yt-iframe');
  if (iframe) iframe.src = '';
  if (menuMusicTimer) { clearTimeout(menuMusicTimer); menuMusicTimer = null; }
  menuMelodyIndex = 0;
}

// ---- CLUE PHASE AMBIENT ----
let clueAmbientTimer = null;
let clueAmbientPlaying = false;
const CLUE_BEAT = [196, 0, 196, 0, 220, 0, 196, 0];
let clueAmbientIndex = 0;

function startClueAmbient() {
  clueAmbientPlaying = true;
  clueAmbientIndex = 0;
  playClueAmbientNote();
}

function playClueAmbientNote() {
  if (!clueAmbientPlaying) return;
  const f = CLUE_BEAT[clueAmbientIndex % CLUE_BEAT.length];
  if (f > 0) playTone(f, 0.1, 'triangle', 0.06);
  clueAmbientIndex++;
  clueAmbientTimer = setTimeout(playClueAmbientNote, 350);
}

function stopClueAmbient() {
  clueAmbientPlaying = false;
  if (clueAmbientTimer) { clearTimeout(clueAmbientTimer); clueAmbientTimer = null; }
}

// Master mute toggle
function toggleMute() {
  audioMuted = !audioMuted;
  const btn = document.getElementById('btn-mute');
  if (audioMuted) {
    btn.textContent = 'üîá';
    stopMenuMusic();
    stopClueAmbient();
  } else {
    btn.textContent = 'üîä';
    // YouTube music is user-triggered
    if (state.phase === 'clue') startClueAmbient();
  }
}


async function saveRoom(data) {
  if (!state.roomCode) return;
  try {
    await db.ref('rooms/' + state.roomCode).set(data);
  } catch(e) { console.error('Firebase save error', e); }
}

async function loadRoom() {
  if (!state.roomCode) return null;
  try {
    const snap = await db.ref('rooms/' + state.roomCode).get();
    if (snap.exists()) return snap.val();
  } catch(e) { console.error('Firebase load error', e); }
  return null;
}

// ==================== UTILITIES ====================
function genCode() {
  return Math.random().toString(36).substring(2,6).toUpperCase();
}

function genId() {
  return Math.random().toString(36).substring(2,10);
}

function pickRandom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById('screen-' + id).classList.add('active');
  state.phase = id;
  // YouTube music bar visibility
  const musicBar = document.getElementById('music-bar');
  if (musicBar) musicBar.style.display = id === 'home' ? 'flex' : 'none';
  if (id !== 'home') {
    stopMenuMusic();
  } else {
    const bar = document.getElementById('music-bar');
    if (bar) bar.style.display = 'flex';
  }
  // Web Audio (clue ambient only)
  if (id === 'clue') {
    setTimeout(startClueAmbient, 500);
  } else {
    stopClueAmbient();
  }
}

function copyCode() {
  navigator.clipboard.writeText(state.roomCode).then(() => {
    const btn = event.target;
    btn.textContent = '‚úÖ Copiado!';
    setTimeout(() => btn.textContent = 'üìã Copiar c√≥digo', 2000);
  });
}

function stopPolling() {
  if (state.pollInterval) { clearInterval(state.pollInterval); state.pollInterval = null; }
}

function startPolling(fn, ms = 2000) {
  stopPolling();
  state.pollInterval = setInterval(fn, ms);
}

// ==================== NAVIGATION ====================
// ==================== LOBBY CHAT ====================
let chatListenerRef = null;

function startChatListener() {
  if (chatListenerRef) { chatListenerRef.off(); chatListenerRef = null; }
  if (!state.roomCode) return;
  const el = document.getElementById('lobby-chat-messages');
  if (!el) return;
  el.innerHTML = '';
  chatListenerRef = db.ref('rooms/' + state.roomCode + '/chat');
  chatListenerRef.on('child_added', snap => {
    const msg = snap.val();
    if (!msg) return;
    const isMe = msg.playerId === state.myId;
    const div = document.createElement('div');
    div.className = 'chat-msg' + (isMe ? ' me' : '');
    div.innerHTML = `<span class="chat-author">${msg.name}:</span> <span class="chat-text">${escapeHtml(msg.text)}</span>`;
    el.appendChild(div);
    el.scrollTop = el.scrollHeight;
  });
}

function stopChatListener() {
  if (chatListenerRef) { chatListenerRef.off(); chatListenerRef = null; }
}

function escapeHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

async function sendChatMessage() {
  const input = document.getElementById('chat-input');
  if (!input) return;
  const text = input.value.trim();
  if (!text || !state.roomCode) return;
  input.value = '';
  const msgRef = db.ref('rooms/' + state.roomCode + '/chat').push();
  await msgRef.set({
    playerId: state.myId,
    name: state.myName || 'Jugador',
    text: text,
    ts: Date.now()
  });
}

async function addBotsToRoom() {
  const roomData = await loadRoom();
  if (!roomData) return;
  const currentCount = Object.keys(roomData.players).length;
  if (currentCount >= 6) { alert('La sala ya est√° llena'); return; }
  const BOT_NAMES = ['Ana', 'Luis', 'Caro', 'Facu', 'Sofi'];
  const BOT_AVATARS = ['ü¶ä', 'üêº', 'ü¶Å', 'üêØ', 'üê∏'];
  let added = 0;
  for (let i = 0; i < BOT_NAMES.length && currentCount + added < 6; i++) {
    const key = 'bot' + (i + 1);
    if (!roomData.players[key]) {
      roomData.players[key] = {
        name: 'Bot ' + BOT_NAMES[i],
        avatar: BOT_AVATARS[i],
        eliminated: false,
        joinedAt: Date.now() + i,
        isBot: true
      };
      added++;
    }
  }
  if (added === 0) { alert('Ya hay suficientes jugadores'); return; }
  await saveRoom(roomData);
}

async function leaveRoom() {
  stopPolling();
  if (state.timerInterval) clearInterval(state.timerInterval);
  if (state.voteTimerInterval) clearInterval(state.voteTimerInterval);
  if (readyTimerInterval) { clearInterval(readyTimerInterval); readyTimerInterval = null; }
  goingToClue = false;

  // Remove player from Firebase room (non-host guests)
  if (state.roomCode && state.myId && !state.isHost) {
    try {
      await db.ref('rooms/' + state.roomCode + '/players/' + state.myId).remove();
    } catch(e) {}
  }
  // If host leaves, delete whole room
  if (state.roomCode && state.isHost) {
    try {
      await db.ref('rooms/' + state.roomCode).remove();
    } catch(e) {}
  }

  // Clear all state
  const wr = document.getElementById('my-word-reminder');
  if (wr) wr.innerHTML = '';
  const rc = document.getElementById('role-reveal-content');
  if (rc) rc.innerHTML = '';
  const cl = document.getElementById('clues-list');
  if (cl) cl.innerHTML = '';
  document.getElementById('lobby-players').innerHTML = '';
  state.gameConfig = null;
  state.myRole = null;
  state.roomCode = null;
  state.myId = null;
  state.isHost = false;
  state.salaName = '';
  state.clues = {};
  state.votes = {};
  state.voteSent = false;
  Object.keys(botTypingState).forEach(k => delete botTypingState[k]);
  stopChatListener();
  showScreen('home');
}

async function startSoloTest() {
  state.gameConfig = null; // clear any previous game state
  const salaName = document.getElementById('input-name').value.trim();
  const playerName = localStorage.getItem('impostor_username') || 'Jugador';
  const botCount = parseInt(document.getElementById('select-bots').value) || 2;
  state.roomCode = 'TEST';
  state.myId = 'solo_' + genId();
  state.myName = playerName;
  state.salaName = salaName || '';
  // Will be set in roomData below
  loadSavedAvatar();
  state.myAvatar = getAvatarSVGString();
  state.isHost = true;

  const BOT_NAMES = ['Ana', 'Luis', 'Caro', 'Facu', 'Sofi'];
  const BOT_AVATARS = ['ü¶ä', 'üêº', 'ü¶Å', 'üêØ', 'üê∏'];

  const fakePlayers = {
    [state.myId]: { name: state.myName, avatar: state.myAvatar, eliminated: false, joinedAt: Date.now() }
  };
  for (let i = 0; i < botCount; i++) {
    fakePlayers[`bot${i+1}`] = {
      name: `Bot ${BOT_NAMES[i]}`,
      avatar: BOT_AVATARS[i],
      eliminated: false,
      joinedAt: Date.now() + i + 1
    };
  }

  const roomData = {
    host: state.myId,
    phase: 'lobby',
    players: fakePlayers,
    game: null,
    clues: {},
    votes: {},
    round: 1,
    impostorIds: [],
    eliminatedCount: 0
  };

  await saveRoom(roomData);
  enterLobby(roomData);
}


async function createRoom() {
  state.gameConfig = null; // clear any previous game state
  const salaName = document.getElementById('input-name').value.trim();
  const playerName = localStorage.getItem('impostor_username') || 'Jugador';
  loadSavedAvatar();

  state.roomCode = genCode();
  state.myId = genId();
  state.myName = playerName;
  state.salaName = salaName || ''; // empty if not set ‚Äî lobby shows "Sala de espera"
  state.myAvatar = getAvatarSVGString();
  state.isHost = true;

  const roomData = {
    host: state.myId,
    salaName: state.salaName,
    phase: 'lobby',
    players: {
      [state.myId]: { name: state.myName, avatar: state.myAvatar, eliminated: false, joinedAt: Date.now() }
    },
    game: null,
    clues: {},
    votes: {},
    round: 1,
    impostorIds: [],
    eliminatedCount: 0
  };

  await saveRoom(roomData);
  enterLobby(roomData);
}

async function joinRoom() {
  const code = document.getElementById('input-code').value.trim().toUpperCase();
  if (!code || code.length < 4) { alert('Ingres√° un c√≥digo de sala v√°lido'); return; }

  const playerName = localStorage.getItem('impostor_username') || 'Jugador';
  state.roomCode = code;
  const roomData = await loadRoom();
  if (!roomData) { alert('Sala no encontrada. Verific√° el c√≥digo.'); return; }
  if (roomData.phase !== 'lobby') { alert('El juego ya comenz√≥. Esper√° la pr√≥xima partida.'); return; }
  if (Object.keys(roomData.players).length >= 6) { alert('La sala est√° llena (m√°ximo 6 jugadores).'); return; }

  state.myId = genId();
  state.myName = playerName;
  loadSavedAvatar();
  state.myAvatar = getAvatarSVGString();
  state.isHost = false;

  roomData.players[state.myId] = { name: state.myName, avatar: state.myAvatar, eliminated: false, joinedAt: Date.now() };
  await saveRoom(roomData);
  enterLobby(roomData);
}

// ==================== LOBBY ====================
function enterLobby(roomData) {
  showScreen('lobby');
  document.getElementById('lobby-code-badge').textContent = state.roomCode;
  document.getElementById('lobby-code-display').textContent = state.roomCode;

  // Show sala name in header
  const salaTitleEl = document.getElementById('lobby-sala-name');
  if (salaTitleEl) {
    const sn = roomData.salaName || state.salaName || '';
    const isReal = sn && sn !== state.roomCode && sn !== 'TEST';
    salaTitleEl.textContent = isReal ? sn : 'Sala de espera';
  }

  if (state.isHost) {
    document.getElementById('host-controls').style.display = 'block';
    document.getElementById('guest-waiting').style.display = 'none';
  } else {
    document.getElementById('host-controls').style.display = 'none';
    document.getElementById('guest-waiting').style.display = 'block';
  }

  renderLobbyPlayers(roomData.players);
  sfxJoin();
  startPolling(pollLobby, 2000);
  startChatListener();
}

function renderLobbyPlayers(players) {
  const grid = document.getElementById('lobby-players');
  const entries = Object.entries(players).sort((a,b) => (a[1].joinedAt||0) - (b[1].joinedAt||0));
  const newHtml = entries.map(([id, p]) => {
    const isSvg = p.avatar && p.avatar.startsWith('<svg');
    const avatarHtml = isSvg
      ? `<span class="avatar-svg">${p.avatar}</span>`
      : `<span class="avatar">${p.avatar}</span>`;
    const displayName = p.name.length > 12 ? p.name.slice(0, 11) + '‚Ä¶' : p.name;
    return `<div class="player-chip ${id === state.myId ? 'me' : ''}">
      ${avatarHtml}
      <div style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:100px;margin:0 auto;" title="${p.name}">${displayName}</div>
      ${id === state.myId ? '<br><span class="badge badge-blue" style="font-size:0.65rem; margin-top:2px;">Vos</span>' : ''}
    </div>`;
  }).join('');
  // Use stable hash to prevent unnecessary re-renders (SVG innerHTML comparison is unreliable)
  const stateKey = entries.map(([id]) => id).join('|');
  if (grid.dataset.stateKey !== stateKey) {
    grid.dataset.stateKey = stateKey;
    grid.innerHTML = newHtml;
  }
  document.getElementById('lobby-count').textContent = entries.length + '/6';
  const btnStart = document.getElementById('btn-start');
  if (btnStart) btnStart.disabled = entries.length < 2;
}

async function pollLobby() {
  const roomData = await loadRoom();
  if (!roomData) return;
  renderLobbyPlayers(roomData.players);
  if (roomData.phase === 'role' && roomData.game) {
    stopPolling();
    startRoleReveal(roomData);
  }
}

// ==================== START GAME ====================
async function startGame() {
  const roomData = await loadRoom();
  if (!roomData) return;

  const playerCount = Object.keys(roomData.players).length;
  if (playerCount < 2) { alert('Necesit√°s al menos 2 jugadores'); return; }

  const impostorCount = parseInt(document.getElementById('select-impostors').value);
  const gameMode = document.getElementById('select-gamemode') ? document.getElementById('select-gamemode').value : 'fixed';
  let catKey = document.getElementById('select-category').value;
  if (catKey === 'random') {
    catKey = pickRandom(Object.keys(WORDS));
  }

  const word = pickRandom(WORDS[catKey]);
  const playerIds = Object.keys(roomData.players);
  const impostorIds = [];
  const shuffled = [...playerIds].sort(() => Math.random() - 0.5);
  for (let i = 0; i < Math.min(impostorCount, playerCount - 1); i++) {
    impostorIds.push(shuffled[i]);
  }

  // Pick a different word from the same category as the impostor hint
  const otherWords = WORDS[catKey].filter(w => w !== word);
  const impostorHint = pickRandom(otherWords);

  roomData.phase = 'role';
  roomData.game = { word, category: catKey, impostorIds, round: 1, impostorHint, gameMode, fixedWord: word };
  roomData.clues = {};
  roomData.votes = {};

  await saveRoom(roomData);
  stopPolling();
  startRoleReveal(roomData);
}

// ==================== ROLE REVEAL ====================
function startRoleReveal(roomData) {
  goingToClue = false; // reset for new round
  if (readyTimerInterval) { clearInterval(readyTimerInterval); readyTimerInterval = null; }
  // Mark eliminated players as auto-ready so they don't block the game
  const me = roomData.players && roomData.players[state.myId];
  if (me && me.eliminated) {
    // Auto-mark eliminated player as ready immediately
    setTimeout(async () => {
      const rd = await loadRoom();
      if (!rd) return;
      if (!rd.ready) rd.ready = {};
      if (!rd.ready[state.myId]) {
        rd.ready[state.myId] = true;
        await saveRoom(rd);
      }
    }, 300);
  }
  const game = roomData.game;
  state.gameConfig = game;
  state.clues = {};
  state.votes = {};

  // Spectator mode: eliminated players watch but don't get a role
  const amIEliminated = roomData.players[state.myId] && roomData.players[state.myId].eliminated;
  if (amIEliminated) {
    state.myRole = 'spectator';
    const content = document.getElementById('role-reveal-content');
    content.innerHTML = `
      <div style="text-align:center; padding:20px 0;">
        <div style="font-size:3.5rem; margin-bottom:12px;">üëÅÔ∏è</div>
        <div style="font-family:'Fredoka One',cursive; font-size:1.5rem; color:var(--muted); margin-bottom:8px;">Est√°s eliminado</div>
        <div style="color:var(--muted); font-size:0.9rem;">Pod√©s seguir viendo la partida</div>
      </div>`;
    startReadyPhase();
    return;
  }

  const isImpostor = game.impostorIds.includes(state.myId);
  state.myRole = isImpostor ? 'impostor' : 'player';

  // Play dramatic sound based on role
  setTimeout(() => isImpostor ? sfxImpostor() : sfxPlayer(), 400);

  const content = document.getElementById('role-reveal-content');
  const modeBadge = game.gameMode === 'rotating' ? ' üîÑ' : ' üîí';
  document.getElementById('round-badge').textContent = 'Ronda ' + (game.round || 1) + modeBadge;

  if (isImpostor) {
    const hint = game.impostorHint;
    const hintBlock = hint
      ? `<div class="word-box" style="border-color:var(--accent1);">
           <div class="word-label">üïµÔ∏è Tu pista (ronda ${game.round || 1})</div>
           <div class="word-value word-flash" style="color:var(--accent1);">${hint}</div>
         </div>
         <p style="color:var(--muted); font-size:0.85rem; margin-bottom:8px;">
           Esta palabra es de la misma categor√≠a que la secreta. ¬°Usala para no levantar sospechas!
         </p>`
      : `<div class="word-box">
           <div class="word-label">Tu palabra</div>
           <div class="word-value">???</div>
         </div>
         <p style="color:var(--muted); font-size:0.85rem;">Sin pista esta ronda. ¬°Escuch√° bien a los dem√°s!</p>`;

    content.innerHTML = `
      <div class="role-dramatic-enter">
        <span class="role-icon role-icon-impostor">üïµÔ∏è</span>
        <div class="role-title impostor">¬°Sos el Impostor!</div>
        <p style="color:var(--muted); margin-bottom:16px;">No sab√©s la palabra secreta. ¬°Intent√° no ser descubierto!</p>
        ${hintBlock}
      </div>
    `;
  } else {
    content.innerHTML = `
      <div class="role-dramatic-enter">
        <span class="role-icon role-icon-player">üòá</span>
        <div class="role-title player">¬°Sos Jugador!</div>
        <p style="color:var(--muted); margin-bottom:16px;">Conoc√©s la palabra. ¬°Encontr√° al impostor sin revelarla!</p>
        <div class="word-box">
          <div class="word-label">La palabra secreta es</div>
          <div class="word-value word-flash">${game.word}</div>
        </div>
        <p style="color:var(--muted); font-size:0.85rem;">Categor√≠a: <strong style="color:var(--accent5);">${CATEGORY_NAMES[game.category]}</strong></p>
      </div>
    `;
  }

  showScreen('role');
  // Reset ready state synchronously via direct save (ready is already reset in nextRound for subsequent rounds)
  // For round 1 it's also clean. Just ensure UI is reset.
  startReadyPhase();
}

// ==================== READY SYSTEM ====================
let readyTimerInterval = null;

async function startReadyPhase() {
  // Reset button
  const btn = document.getElementById('btn-ready');
  btn.disabled = false;
  btn.textContent = '¬°Entendido! üëç';

  // Show counter immediately with initial count
  const countEl = document.getElementById('ready-count-text');
  const timerEl = document.getElementById('ready-timer-text');

  // Load room to get initial state
  const roomData = await loadRoom();
  if (!roomData) return;
  const activePlayers = Object.keys(roomData.players).filter(id => !roomData.players[id].eliminated);
  const readyIds = Object.keys(roomData.ready || {}).filter(id => activePlayers.includes(id));
  const readyNow = readyIds.length;
  if (countEl) {
    const names = readyIds.map(id => roomData.players[id] ? (id === state.myId ? 'Vos' : roomData.players[id].name) : '?');
    countEl.textContent = `${readyNow}/${activePlayers.length}`;
    countEl.title = names.length > 0 ? 'Listos: ' + names.join(', ') : '';
    countEl.style.cursor = names.length > 0 ? 'help' : '';
  }

  // Start 30s countdown IMMEDIATELY
  let t = 30;
  if (timerEl) timerEl.textContent = t + 's';
  if (readyTimerInterval) clearInterval(readyTimerInterval);
  readyTimerInterval = setInterval(() => {
    t--;
    if (timerEl) timerEl.textContent = t + 's';
    if (t <= 0) {
      clearInterval(readyTimerInterval);
      stopPolling();
      goToCluePhase();
    }
  }, 1000);

  // Start polling for others' ready state right away
  startPolling(pollReady, 1000);
}

async function markReady() {
  // Visually confirm they clicked
  const btn = document.getElementById('btn-ready');
  btn.disabled = true;
  btn.textContent = '‚úÖ Listo!';

  const roomData = await loadRoom();
  if (!roomData) return;
  if (!roomData.ready) roomData.ready = {};
  roomData.ready[state.myId] = true;
  await saveRoom(roomData);

  // Update counter immediately
  const activePlayers = Object.keys(roomData.players).filter(id => !roomData.players[id].eliminated);
  const readyNow = Object.keys(roomData.ready).filter(id => activePlayers.includes(id)).length;
  const countEl = document.getElementById('ready-count-text');
  if (countEl) countEl.textContent = `${readyNow}/${activePlayers.length}`;

  // Bots auto-ready after a short delay (host only)
  if (state.roomCode === 'TEST') {
    setTimeout(async () => {
      const rd = await loadRoom();
      if (!rd || !rd.ready) return;
      let ch = false;
      Object.keys(rd.players).forEach(id => {
        if (id !== state.myId && !rd.players[id].eliminated && !rd.ready[id]) {
          rd.ready[id] = true; ch = true;
        }
      });
      if (ch) await saveRoom(rd);
    }, 800); // small delay so you can see the counter update
  }
}

async function pollReady() {
  const roomData = await loadRoom();
  if (!roomData) return;

  // Bot auto-ready is handled in markReady() with a delay ‚Äî nothing to do here for TEST mode

  const activePlayers = Object.keys(roomData.players).filter(id => !roomData.players[id].eliminated);
  const readyCount = Object.keys(roomData.ready || {}).filter(id => activePlayers.includes(id)).length;
  const total = activePlayers.length;

  const countEl = document.getElementById('ready-count-text');
  if (countEl) countEl.textContent = `${readyCount}/${total}`;

  if (readyCount >= total) {
    stopPolling();
    clearInterval(readyTimerInterval);
    goToCluePhase();
  }
}

// ==================== CLUE PHASE ====================
let goingToClue = false;
async function goToCluePhase() {
  if (goingToClue) return;
  goingToClue = true;
  // Kill ready timer before anything else to prevent race conditions
  if (readyTimerInterval) { clearInterval(readyTimerInterval); readyTimerInterval = null; }
  stopPolling();
  showScreen('clue');

  const game = state.gameConfig;
  document.getElementById('clue-category-tag').innerHTML = `<span class="category-tag">${CATEGORY_NAMES[game.category]}</span>`;

  // Always get fresh game config from room to avoid stale word from previous game
  const freshRoom = await loadRoom();
  if (freshRoom && freshRoom.game) {
    state.gameConfig = freshRoom.game;
  }
  const freshGame = state.gameConfig;
  if (!freshGame) return;

  const wordReminder = document.getElementById('my-word-reminder');
  if (state.myRole === 'player') {
    wordReminder.innerHTML = `Tu palabra: <strong style="color:var(--accent2);">${freshGame.word}</strong>`;
  } else {
    if (freshGame.impostorHint) {
      wordReminder.innerHTML = `üïµÔ∏è Tu pista: <strong style="color:var(--accent1);">${freshGame.impostorHint}</strong>`;
    } else {
      wordReminder.innerHTML = `<strong style="color:var(--accent1);">Impostor üïµÔ∏è ‚Äî sin pista</strong>`;
    }
  }

  // Check if this player is eliminated ‚Äî spectators watch but can't participate
  const amIEliminated = freshRoom && freshRoom.players[state.myId] && freshRoom.players[state.myId].eliminated;
  if (amIEliminated) {
    document.getElementById('clue-input-area').style.display = 'none';
    document.getElementById('clue-submitted-msg').style.display = 'block';
    document.getElementById('clue-submitted-msg').innerHTML = `
      <div class="info-box" style="text-align:center; border-color:var(--muted);">
        üëÅÔ∏è Est√°s eliminado ‚Äî pod√©s ver el juego pero no participar
      </div>`;
  } else {
    document.getElementById('clue-input-area').style.display = 'block';
    document.getElementById('clue-submitted-msg').style.display = 'none';
    document.getElementById('btn-submit-clue').disabled = false;
    document.getElementById('input-clue').value = '';
  }
  const cl = document.getElementById('clues-list');
  if (cl) { cl.innerHTML = ''; delete cl.dataset.stateKey; }
  // Clear category and word reminder to avoid flash of old content
  const catTag = document.getElementById('clue-category-tag');
  if (catTag) catTag.innerHTML = '';

  // Reset bot typing state for new round
  Object.keys(botTypingState).forEach(k => delete botTypingState[k]);

  startTimer(60);
  startPolling(pollClues, 500); // poll faster for live typing feel
  goingToClue = false;
}

// Broadcast player's current typing text to room
let typingBroadcastTimeout = null;
async function broadcastTyping() {
  const val = document.getElementById('input-clue').value;
  // Debounce slightly so we don't save on every keystroke
  clearTimeout(typingBroadcastTimeout);
  typingBroadcastTimeout = setTimeout(async () => {
    const roomData = await loadRoom();
    if (!roomData || roomData.clues[state.myId]) return; // already submitted
    if (!roomData.typing) roomData.typing = {};
    if (val.trim()) {
      roomData.typing[state.myId] = '1'; // just a presence marker ‚Äî text stays private
    } else {
      delete roomData.typing[state.myId];
    }
    await saveRoom(roomData);
  }, 100);
}

function startTimer(seconds) {
  if (state.timerInterval) clearInterval(state.timerInterval);
  state.timerValue = seconds;
  const circle = document.getElementById('timer-circle');
  const text = document.getElementById('timer-text');
  const totalDash = 314;

  const update = () => {
    if (!circle || !text) return;
    text.textContent = state.timerValue;
    const offset = totalDash * (1 - state.timerValue / seconds);
    circle.style.strokeDashoffset = offset;
    const pct = state.timerValue / seconds;
    if (pct > 0.5) circle.style.stroke = 'var(--accent3)';
    else if (pct > 0.25) circle.style.stroke = 'var(--accent2)';
    else circle.style.stroke = 'var(--accent1)';

    if (state.timerValue <= 0) {
      clearInterval(state.timerInterval);
      sfxTimerEnd();
      autoSubmitClue();
    } else {
      if (state.timerValue <= 10) sfxTickUrgent();
      else if (state.timerValue % 10 === 0) sfxTick();
      state.timerValue--;
    }
  };
  update();
  state.timerInterval = setInterval(update, 1000);
}

function autoSubmitClue() {
  const inp = document.getElementById('input-clue');
  if (inp && !state.clues[state.myId]) {
    const val = inp.value.trim();
    submitClueValue(val || '...');
  }
}

async function submitClue() {
  const val = document.getElementById('input-clue').value.trim();
  if (!val) { alert('Escrib√≠ una pista primero'); return; }
  submitClueValue(val);
}

async function submitClueValue(clueText) {
  if (state.timerInterval) clearInterval(state.timerInterval);
  stopClueAmbient();
  sfxClueSubmit();
  document.getElementById('clue-input-area').style.display = 'none';
  document.getElementById('clue-submitted-msg').style.display = 'block';

  const roomData = await loadRoom();
  if (!roomData) return;
  if (!roomData.clues) roomData.clues = {};
  roomData.clues[state.myId] = clueText;
  await saveRoom(roomData);
  state.clues = roomData.clues;
  renderClues(roomData.clues, roomData.players);
}

const BOT_CLUES = ['Genio', 'Famoso', 'Incre√≠ble', 'Leyenda', '√önico', 'Campe√≥n', 'Icono', 'N√∫mero 1', 'Crack', '√âpico', 'Hist√≥rico'];
const botTypingState = {}; // track each bot's simulated typing phase

// Returns true if this client should simulate bots (host + room has bot players)
function hasLocalBots(roomData) {
  if (!state.isHost) return false;
  if (!roomData || !roomData.players) return false;
  if (state.roomCode === 'TEST') return true;
  return Object.values(roomData.players).some(p => p.isBot);
}

function getBotIds(roomData) {
  if (!roomData || !roomData.players) return [];
  if (state.roomCode === 'TEST') {
    return Object.keys(roomData.players).filter(id => id !== state.myId);
  }
  return Object.keys(roomData.players).filter(id => roomData.players[id].isBot);
}

async function pollClues() {
  const roomData = await loadRoom();
  if (!roomData) return;

  // Simulate bot typing/clue submission (host only, when bots are present)
  if (hasLocalBots(roomData)) {
    const now = Date.now();
    let changed = false;

    getBotIds(roomData).forEach(id => {
      if (roomData.players[id].eliminated || roomData.clues[id]) return;

      if (!botTypingState[id]) {
        // Bot starts "typing" 1-3s after game enters clue phase
        botTypingState[id] = { startAt: now + 1000 + Math.random() * 2000, word: pickRandom(BOT_CLUES), phase: 'waiting' };
      }

      const bot = botTypingState[id];
      if (now < bot.startAt) return; // not started yet

      if (bot.phase === 'waiting') {
        bot.phase = 'typing';
        bot.typingEnd = now + 1500 + Math.random() * 2000; // type for 1.5-3.5s
      }

      if (bot.phase === 'typing') {
        // Simulate partial text while typing
        const elapsed = now - bot.startAt;
        const total = bot.typingEnd - bot.startAt;
        const pct = Math.min(elapsed / total, 1);
        const partialLen = Math.floor(pct * bot.word.length);
        if (!roomData.typing) roomData.typing = {};
        roomData.typing[id] = '1'; // just a marker ‚Äî actual text stays hidden
        changed = true;

        if (now >= bot.typingEnd) {
          // Done typing ‚Äî submit clue
          bot.phase = 'done';
          roomData.clues[id] = bot.word;
          if (roomData.typing) delete roomData.typing[id];
        }
      }
    });

    if (changed) await saveRoom(roomData);
  }

  state.clues = roomData.clues || {};
  renderClues(roomData.clues || {}, roomData.players, roomData.typing || {});

  const playerCount = Object.keys(roomData.players).filter(id => !roomData.players[id].eliminated).length;
  const clueCount = Object.keys(roomData.clues || {}).length;

  if (clueCount >= playerCount) {
    stopPolling();
    if (state.timerInterval) clearInterval(state.timerInterval);
    setTimeout(() => goToVote(roomData), 1500);
  }
}


function onAvatarNameInput() {
  const val = document.getElementById('avatar-username').value.trim();
  const nameEl = document.getElementById('avatar-name-preview');
  if (nameEl) nameEl.textContent = val || 'Tu personaje';
}

function renderAvatar(avatar, size = 28) {
  if (avatar && avatar.startsWith('<svg')) {
    return `<span style="width:${size}px;height:${size*1.2}px;display:inline-flex;flex-shrink:0;vertical-align:middle;">${avatar}</span>`;
  }
  return `<span style="font-size:${size*0.07}rem;vertical-align:middle;">${avatar}</span>`;
}
function renderClues(clues, players, typing) {
  const list = document.getElementById('clues-list');
  if (!list) return;
  const activePlayers = Object.entries(players).filter(([id, p]) => !p.eliminated);
  typing = typing || {};
  // Did I already submit my clue?
  const myClueSubmitted = !!(clues[state.myId]) || state.myRole === 'spectator';

  activePlayers.forEach(([id, p]) => {
    const clue = clues[id];
    const typingText = typing[id] || '';
    // Hide others' clues until I submit mine (prevent cheating)
    const hideThisClue = !myClueSubmitted && id !== state.myId;
    let item = list.querySelector(`[data-id="${id}"]`);

    if (!item) {
      // First time ‚Äî create the item
      item = document.createElement('div');
      item.dataset.id = id;
      item.className = 'clue-item waiting';
      item.innerHTML = `${renderAvatar(p.avatar, 32)}<div class="clue-info"><div class="clue-name-row">${p.name}</div><div class="clue-text">esperando...</div></div>`;
      list.appendChild(item);
    }

    const nameRow = item.querySelector('.clue-name-row');
    const textEl = item.querySelector('.clue-text');

    if (hideThisClue) {
      // Before I submit: show status but NOT the clue text
      if (clue) {
        if (item.dataset.state !== 'done-hidden') {
          item.dataset.state = 'done-hidden';
          item.className = 'clue-item done';
          nameRow.innerHTML = `${p.name} <span style="color:var(--accent3);font-size:0.75rem;">‚úì listo</span>`;
          textEl.textContent = '???'; // hidden until I submit
          textEl.style.filter = 'blur(6px)';
          textEl.style.userSelect = 'none';
        }
      } else if (typingText) {
        item.dataset.state = 'typing';
        item.className = 'clue-item typing';
        nameRow.innerHTML = `${p.name} <span style="color:var(--accent4);font-size:0.75rem;">‚úçÔ∏è escribiendo</span>`;
        textEl.textContent = '';
        textEl.style.filter = '';
      } else {
        if (item.dataset.state !== 'waiting') {
          item.dataset.state = 'waiting';
          item.className = 'clue-item waiting';
          nameRow.textContent = p.name;
          textEl.textContent = 'esperando...';
          textEl.style.filter = '';
        }
      }
    } else if (clue) {
      if (item.dataset.state !== 'done') {
        item.dataset.state = 'done';
        item.className = 'clue-item done';
        nameRow.innerHTML = `${p.name} <span style="color:var(--accent3);font-size:0.75rem;">‚úì listo</span>`;
        textEl.textContent = clue;
        textEl.style.filter = '';
      }
    } else if (typingText) {
      item.dataset.state = 'typing';
      item.className = 'clue-item typing';
      nameRow.innerHTML = `${p.name} <span style="color:var(--accent4);font-size:0.75rem;">‚úçÔ∏è escribiendo</span>`;
      textEl.textContent = '';
      textEl.style.filter = '';
    } else {
      if (item.dataset.state !== 'waiting') {
        item.dataset.state = 'waiting';
        item.className = 'clue-item waiting';
        nameRow.textContent = p.name;
        textEl.textContent = 'esperando...';
        textEl.style.filter = '';
      }
    }
  });
}

// ==================== VOTE PHASE ====================
function goToVote(roomData) {
  showScreen('vote');
  const voteTitleEl = document.querySelector('#screen-vote .section-title');
  if (voteTitleEl) voteTitleEl.textContent = 'üì¶ ¬°A votar!';
  const clues = roomData.clues || {};
  const players = roomData.players;

  const summary = document.getElementById('vote-clues-summary');
  // Show ALL clues including mine, sorted by joinedAt, using proper avatar rendering
  summary.innerHTML = Object.entries(players)
    .filter(([id, p]) => !p.eliminated && clues[id])
    .sort((a,b) => (a[1].joinedAt||0)-(b[1].joinedAt||0))
    .map(([id, p]) => {
      const clue = clues[id];
      const isMe = id === state.myId;
      return `<div class="clue-item${isMe?' done':''}">${renderAvatar(p.avatar, 32)}<div><div class="clue-name">${p.name}${isMe?' <span style="color:var(--accent4);font-size:0.7rem;">(vos)</span>':''}</div><div class="clue-text">${clue}</div></div></div>`;
    }).join('');

  const voteList = document.getElementById('vote-list');
  voteList.innerHTML = Object.entries(players)
    .filter(([id, p]) => !p.eliminated)
    .sort((a,b) => (a[1].joinedAt||0)-(b[1].joinedAt||0))
    .map(([id, p]) => {
      if (id === state.myId) return '';
      return `<div class="vote-item" id="vote-item-${id}" onclick="selectVote('${id}')">${renderAvatar(p.avatar, 30)} ${p.name}</div>`;
    }).join('');

  // RESET vote state completely for each round
  state.selectedVote = null;
  state.voteSent = false;
  const btnVote = document.getElementById('btn-vote');
  document.getElementById('vote-waiting').style.display = 'none';

  // Eliminated players spectate ‚Äî can't vote
  const amIEliminated = roomData.players[state.myId] && roomData.players[state.myId].eliminated;
  if (amIEliminated) {
    btnVote.style.display = 'none';
    document.getElementById('vote-list').innerHTML = `
      <div class="info-box" style="text-align:center; border-color:var(--muted); margin-top:8px;">
        üëÅÔ∏è Est√°s eliminado ‚Äî pod√©s ver las pistas pero no votar
      </div>`;
  } else {
    btnVote.style.display = 'block';
    btnVote.disabled = true;
  }

  let vt = 30;
  const vtText = document.getElementById('vote-timer-text');
  if (state.voteTimerInterval) clearInterval(state.voteTimerInterval);
  vtText.textContent = `‚è∞ ${vt}s`;
  state.voteTimerInterval = setInterval(() => {
    vt--;
    vtText.textContent = `‚è∞ ${vt}s`;
    if (vt <= 0) {
      clearInterval(state.voteTimerInterval);
      if (!state.voteSent) autoVote();
    }
  }, 1000);

  startPolling(pollVotes, 2000);
}

function selectVote(id) {
  state.selectedVote = id;
  document.querySelectorAll('.vote-item').forEach(el => el.classList.remove('selected'));
  const el = document.getElementById('vote-item-' + id);
  if (el) el.classList.add('selected');
  document.getElementById('btn-vote').disabled = false;
}

function autoVote() {
  if (!state.voteSent) {
    if (state.selectedVote) confirmVote();
    else {
      // pick random
      const items = document.querySelectorAll('.vote-item:not(.eliminated)');
      if (items.length > 0) {
        const el = items[Math.floor(Math.random() * items.length)];
        const id = el.id.replace('vote-item-', '');
        selectVote(id);
        confirmVote();
      }
    }
  }
}

async function confirmVote() {
  if (!state.selectedVote) return;
  state.voteSent = true;
  sfxVote();
  if (state.voteTimerInterval) clearInterval(state.voteTimerInterval);

  document.getElementById('btn-vote').style.display = 'none';
  document.getElementById('vote-waiting').style.display = 'block';

  const roomData = await loadRoom();
  if (!roomData) return;
  if (!roomData.votes) roomData.votes = {};
  roomData.votes[state.myId] = state.selectedVote;
  await saveRoom(roomData);
}

async function pollVotes() {
  // Load fresh data first
  let roomData = await loadRoom();
  if (!roomData) return;

  // Host simulates bot votes after player has voted
  if (hasLocalBots(roomData) && state.voteSent) {
    const eligible = roomData.phase === 'tiebreak'
      ? (roomData.tiebreakPlayers || [])
      : Object.keys(roomData.players).filter(id => !roomData.players[id].eliminated);
    let changed = false;
    getBotIds(roomData).forEach(id => {
      if (roomData.players[id].eliminated || roomData.votes[id]) return;
      const allOptions = eligible.filter(vid => vid !== id);
      if (allOptions.length > 0) {
        roomData.votes[id] = allOptions[Math.floor(Math.random() * allOptions.length)];
        changed = true;
      }
    });
    if (changed) {
      await saveRoom(roomData);
      // Reload after saving bots votes
      roomData = await loadRoom();
      if (!roomData) return;
    }
  }

  const activePlayers = Object.entries(roomData.players).filter(([id, p]) => !p.eliminated);
  const votes = roomData.votes || {};
  const voteCount = Object.keys(votes).length;
  const totalActive = activePlayers.length;

  // Advance when everyone has voted OR all active players that CAN vote did
  // (a player can't vote for themselves, but they still cast a vote for someone else)
  if (voteCount >= totalActive) {
    stopPolling();
    setTimeout(() => showVoteResults(roomData), 500);
  }
}


function goToTiebreakVote(roomData) {
  const tiedIds = roomData.tiebreakPlayers || [];
  const players = roomData.players;
  const clues = roomData.clues || {};

  showScreen('vote');
  // Update screen title for tiebreak
  const voteTitleEl = document.querySelector('#screen-vote .section-title');
  if (voteTitleEl) voteTitleEl.textContent = '‚öñÔ∏è Desempate';
  // Reset timer display
  const vtTextReset = document.getElementById('vote-timer-text');
  if (vtTextReset) vtTextReset.textContent = '';

  // Show only tied players' clues as reference
  const summary = document.getElementById('vote-clues-summary');
  summary.innerHTML = `<div class="info-box" style="margin-bottom:8px; text-align:center;">‚öñÔ∏è <strong>Desempate</strong> ‚Äî vot√° entre los empatados</div>` +
    tiedIds.map(id => {
      const p = players[id];
      if (!p) return '';
      return `<div class="clue-item done">${renderAvatar(p.avatar, 32)}<div><div class="clue-name">${p.name}</div><div class="clue-text">${clues[id] || '...'}</div></div></div>`;
    }).join('');

  // Vote list ‚Äî only tied players
  const voteList = document.getElementById('vote-list');
  voteList.innerHTML = tiedIds
    .filter(id => id !== state.myId)
    .map(id => {
      const p = players[id];
      if (!p) return '';
      return `<div class="vote-item" id="vote-item-${id}" onclick="selectVote('${id}')">${renderAvatar(p.avatar, 30)} ${p.name}</div>`;
    }).join('');

  state.selectedVote = null;
  state.voteSent = false;
  const btnVote = document.getElementById('btn-vote');
  // Reset vote UI completely
  btnVote.style.display = 'block';
  btnVote.disabled = true;
  btnVote.textContent = 'Votar üéØ';
  document.getElementById('vote-waiting').style.display = 'none';

  // Kill any existing vote timer before starting new one
  if (state.voteTimerInterval) { clearInterval(state.voteTimerInterval); state.voteTimerInterval = null; }

  let vt = 30;
  const vtText = document.getElementById('vote-timer-text');
  vtText.textContent = `‚è∞ ${vt}s`;
  state.voteTimerInterval = setInterval(() => {
    vt--;
    vtText.textContent = `‚è∞ ${vt}s`;
    if (vt <= 0) {
      clearInterval(state.voteTimerInterval);
      if (!state.voteSent) autoVote();
    }
  }, 1000);

  startPolling(pollVotes, 2000);
}
// ==================== VOTE RESULTS ====================
async function showVoteResults(roomData) {
  const votes = roomData.votes || {};
  const players = roomData.players;

  // Count votes
  const voteCounts = {};
  Object.values(votes).forEach(id => {
    voteCounts[id] = (voteCounts[id] || 0) + 1;
  });

  // Find who got most votes ‚Äî detect ties
  // In tiebreak mode, only count votes for the tied players
  const tiebreakMode = roomData.phase === 'tiebreak';
  const tiebreakIds = roomData.tiebreakPlayers || [];
  let maxVotes = 0;
  Object.entries(voteCounts).forEach(([id, cnt]) => {
    if (tiebreakMode && !tiebreakIds.includes(id)) return; // ignore votes outside tiebreak
    if (cnt > maxVotes) maxVotes = cnt;
  });
  const relevantEntries = tiebreakMode
    ? Object.entries(voteCounts).filter(([id]) => tiebreakIds.includes(id))
    : Object.entries(voteCounts);
  const topVoted = relevantEntries.filter(([id, cnt]) => cnt === maxVotes).map(([id]) => id);
  const isTie = topVoted.length > 1 && maxVotes > 0;
  const eliminated = isTie ? null : (topVoted[0] || null);

  // Bars with stagger animation
  const barsEl = document.getElementById('vote-results-bars');

  // Build vote detail: who voted for whom ‚Äî remove any previous before adding
  const oldDetail = document.getElementById('vote-detail-accordion');
  if (oldDetail) oldDetail.remove();
  const voteDetail = Object.entries(votes).map(([voterId, targetId]) => {
    const voter = players[voterId];
    const target = players[targetId];
    if (!voter || !target) return '';
    const voterName = voterId === state.myId ? '<strong>Vos</strong>' : voter.name;
    return `<div style="font-size:0.8rem;color:var(--muted);padding:2px 0;">${voterName} ‚Üí ${target.name}</div>`;
  }).join('');
  if (voteDetail) {
    const detailEl = document.createElement('details');
    detailEl.id = 'vote-detail-accordion';
    detailEl.style.cssText = 'margin:8px 0;cursor:pointer;';
    detailEl.innerHTML = `<summary style="color:var(--accent4);font-size:0.85rem;font-weight:700;">üëÅÔ∏è Ver votos individuales</summary><div style="padding:8px;background:var(--card2);border-radius:8px;margin-top:4px;">${voteDetail}</div>`;
    barsEl.parentNode.insertBefore(detailEl, barsEl);
  }

  const total = Object.values(voteCounts).reduce((a,b) => a+b, 0) || 1;
  // In tiebreak mode, only show tiebreak players in bars
  const tiebreakModeBar = roomData.phase === 'tiebreak';
  const tiebreakIdsBar = roomData.tiebreakPlayers || [];
  barsEl.innerHTML = Object.entries(players)
    .filter(([id, p]) => !p.eliminated && (!tiebreakModeBar || tiebreakIdsBar.includes(id)))
    .sort((a,b)=> (voteCounts[b[0]]||0)-(voteCounts[a[0]]||0))
    .map(([id, p], i) => {
      const cnt = voteCounts[id] || 0;
      const pct = Math.round((cnt / total) * 100);
      const isSvg = p.avatar && p.avatar.startsWith('<svg');
      const avatarHtml = isSvg
        ? `<span style="width:24px;height:28px;display:inline-flex;vertical-align:middle;">${p.avatar}</span>`
        : `<span>${p.avatar}</span>`;
      return `<div class="vote-bar-wrap result-dramatic" style="animation-delay:${i*0.12}s">
        <div class="vote-bar-name"><span>${avatarHtml} ${p.name}</span><span>${cnt} voto${cnt!==1?'s':''}</span></div>
        <div class="vote-bar"><div class="vote-bar-fill" style="width:${pct}%"></div></div>
      </div>`;
    }).join('');

  // Elimination result
  const elimEl = document.getElementById('elimination-result');
  const isImpostor = eliminated && state.gameConfig.impostorIds.includes(eliminated);
  const elimPlayer = eliminated ? players[eliminated] : null;

  if (isTie) {
    // TIE: show result then auto-advance to tiebreak after countdown
    const tiedNames = topVoted.map(id => players[id] ? players[id].name : '?').join(' y ');
    let tieCountdown = 5;
    elimEl.innerHTML = `
      <div class="result-dramatic" style="animation-delay:0.3s">
        <div style="font-size:3rem; margin-bottom:8px;">‚öñÔ∏è</div>
        <div style="font-family:'Fredoka One',cursive; font-size:1.5rem; color:var(--accent2);">¬°Empate!</div>
        <div style="color:var(--muted); margin-bottom:8px;">${tiedNames} tienen los mismos votos</div>
        <div id="tie-countdown" style="color:var(--accent4); font-size:1rem; font-weight:700;">Desempate en ${tieCountdown}s...</div>
      </div>
    `;
    // Hide next-round button ‚Äî auto-advance
    document.getElementById('btn-next-round').style.display = 'none';

    // Save tiebreak state (host only), track tiebreak round count
    let tiebreakRound = 0;
    if (state.isHost) {
      const fresh = await loadRoom();
      if (fresh) {
        tiebreakRound = (fresh.tiebreakRound || 0) + 1;
        if (tiebreakRound >= 2) {
          // Second tiebreak ‚Äî declare no winner
          fresh.phase = 'win';
          fresh.winner = 'draw';
          fresh.tiebreakRound = 0;
          await saveRoom(fresh);
        } else {
          fresh.phase = 'tiebreak';
          fresh.tiebreakPlayers = topVoted;
          fresh.tiebreakRound = tiebreakRound;
          fresh.votes = {};
          await saveRoom(fresh);
        }
      }
    } else {
      // Non-host: read tiebreakRound from room
      const fresh = await loadRoom();
      if (fresh) tiebreakRound = fresh.tiebreakRound || 0;
    }

    // Countdown then auto-trigger tiebreak OR draw screen
    const tieTimer = setInterval(() => {
      tieCountdown--;
      const cdEl = document.getElementById('tie-countdown');
      if (cdEl) cdEl.textContent = tieCountdown > 0 ? `Desempate en ${tieCountdown}s...` : (tiebreakRound >= 2 ? '¬°Nadie gana!' : '¬°Empezando desempate!');
      if (tieCountdown <= 0) {
        clearInterval(tieTimer);
        loadRoom().then(rd => {
          if (!rd) return;
          if (rd.phase === 'win' && rd.winner === 'draw') {
            showDrawScreen(rd);
          } else if (rd.phase === 'tiebreak') {
            goToTiebreakVote(rd);
          }
        });
      }
    }, 1000);
  } else if (eliminated && elimPlayer) {
    if (isImpostor) {
      elimEl.innerHTML = `
        <div class="result-dramatic" style="animation-delay:0.3s">
          <div style="font-size:3rem; margin-bottom:8px;">üéØ</div>
          <div style="font-family:'Fredoka One',cursive; font-size:1.5rem; color:var(--accent3);">¬°Atrapado!</div>
          <div style="color:var(--muted);">${renderAvatar(elimPlayer.avatar,24)} <strong>${elimPlayer.name}</strong> era el impostor</div>
        </div>
      `;
    } else {
      elimEl.innerHTML = `
        <div class="result-dramatic" style="animation-delay:0.3s">
          <div style="font-size:3rem; margin-bottom:8px;">üò¨</div>
          <div style="font-family:'Fredoka One',cursive; font-size:1.5rem; color:var(--accent1);">¬°Error!</div>
          <div style="color:var(--muted);">${renderAvatar(elimPlayer.avatar,24)} <strong>${elimPlayer.name}</strong> era inocente</div>
        </div>
      `;
    }

    // Update room: eliminate player
    if (state.isHost) {
      const fresh = await loadRoom();
      if (fresh) {
        fresh.players[eliminated].eliminated = true;
        fresh.eliminatedCount = (fresh.eliminatedCount || 0) + 1;

        const remainingImpostors = state.gameConfig.impostorIds.filter(id => !fresh.players[id].eliminated);
        const remainingPlayers = Object.entries(fresh.players).filter(([id,p]) => !p.eliminated && !state.gameConfig.impostorIds.includes(id));

        if (remainingImpostors.length === 0) {
          fresh.phase = 'win';
          fresh.winner = 'players';
        } else if (remainingImpostors.length >= remainingPlayers.length) {
          fresh.phase = 'win';
          fresh.winner = 'impostors';
        } else {
          fresh.phase = 'result';
          fresh.round = (fresh.round || 1) + 1;
        }
        await saveRoom(fresh);
      }
    }
  }

  showScreen('vote-result');
  sfxReveal();
  document.getElementById('btn-next-round').style.display = state.isHost ? 'block' : 'none';
  // Play caught/error sound after bars animate
  setTimeout(() => {
    if (isImpostor) sfxCaught(); else sfxImpostorWins();
  }, 800);

  if (!state.isHost) {
    startPolling(pollForNextPhase, 2000);
  }
}

async function pollForNextPhase() {
  const roomData = await loadRoom();
  if (!roomData) return;
  if (roomData.phase === 'win') {
    stopPolling();
    showWin(roomData);
  } else if (roomData.phase === 'role') {
    stopPolling();
    startRoleReveal(roomData);
  }
}

async function nextRound() {
  const roomData = await loadRoom();
  if (!roomData) return;

  if (roomData.phase === 'win') {
    showWin(roomData);
    return;
  }

  if (roomData.phase === 'tiebreak') {
    // Tiebreak: go directly to tiebreak vote
    goToTiebreakVote(roomData);
    return;
  }

  if (roomData.phase === 'result') {
    const catKey = roomData.game.category;
    const gameMode = roomData.game.gameMode || 'fixed';
    const impostorCount = roomData.game.impostorIds.length;
    const activePlayers = Object.keys(roomData.players).filter(id => !roomData.players[id].eliminated);

    // FIXED mode: keep the same impostor(s) all game
    // ROTATING mode: rotate roles so previous impostors become players
    let newImpostors;
    if (gameMode === 'fixed') {
      // Keep same impostors ‚Äî only remove eliminated ones
      newImpostors = (roomData.game.fixedImpostors || roomData.game.impostorIds)
        .filter(id => activePlayers.includes(id));
      // Store fixedImpostors permanently on first round
      if (!roomData.game.fixedImpostors) roomData.game.fixedImpostors = [...roomData.game.impostorIds];
    } else {
      // Rotating: previous impostors go to back so they won't be picked again unless necessary
      const prevImpostors = roomData.game.impostorIds || [];
      const nonImpostors = activePlayers.filter(id => !prevImpostors.includes(id));
      const shuffledNon = [...nonImpostors].sort(() => Math.random() - 0.5);
      const shuffledPrev = [...prevImpostors].filter(id => activePlayers.includes(id)).sort(() => Math.random() - 0.5);
      const candidatePool = [...shuffledNon, ...shuffledPrev];
      newImpostors = candidatePool.slice(0, Math.min(impostorCount, activePlayers.length - 1));
    }

    let newWord, newHint;

    if (gameMode === 'fixed') {
      newWord = roomData.game.fixedWord || roomData.game.word;
      const usedHints = roomData.game.usedHints || [roomData.game.impostorHint];
      const available = WORDS[catKey].filter(w => w !== newWord && !usedHints.includes(w));
      newHint = available.length > 0 ? pickRandom(available) : pickRandom(WORDS[catKey].filter(w => w !== newWord));
      roomData.game.usedHints = [...usedHints, newHint];
    } else {
      const usedWords = roomData.game.usedWords || [roomData.game.word];
      const availableWords = WORDS[catKey].filter(w => !usedWords.includes(w));
      newWord = availableWords.length > 0 ? pickRandom(availableWords) : pickRandom(WORDS[catKey]);
      newHint = pickRandom(WORDS[catKey].filter(w => w !== newWord));
      roomData.game.usedWords = [...usedWords, newWord];
      roomData.game.fixedWord = newWord;
    }

    roomData.game.word = newWord;
    roomData.game.impostorIds = newImpostors;
    roomData.game.round = roomData.round;
    roomData.game.impostorHint = newHint;
    roomData.clues = {};
    roomData.votes = {};
    roomData.ready = {}; // reset ready state for new round
    roomData.phase = 'role';
    await saveRoom(roomData);

    state.gameConfig = roomData.game;
    startRoleReveal(roomData);
  }
}

// ==================== WIN ====================
function showWin(roomData) {
  stopPolling();
  if (roomData.winner === 'draw') { showDrawScreen(roomData); return; }
  const winner = roomData.winner;

  // Build impostor cards - small and professional
  const impostorCards = state.gameConfig.impostorIds.map(id => {
    const p = roomData.players[id];
    if (!p) return '';
    const isSvg = p.avatar && p.avatar.startsWith('<svg');
    const avatarHtml = isSvg
      ? `<div style="width:64px;height:76px;flex-shrink:0;">${p.avatar}</div>`
      : `<div style="font-size:2.5rem;line-height:1;">${p.avatar}</div>`;
    return `<div style="display:flex;flex-direction:column;align-items:center;gap:6px;">
      ${avatarHtml}
      <div style="font-weight:700;font-size:0.9rem;color:var(--accent1);">${p.name}</div>
    </div>`;
  }).join('');

  document.getElementById('win-icon').textContent = winner === 'players' ? 'üèÜ' : 'üïµÔ∏è';
  document.getElementById('win-title').textContent = winner === 'players' ? '¬°Ganaron los jugadores!' : '¬°Ganaron los impostores!';
  document.getElementById('win-subtitle').textContent = winner === 'players' ? 'Descubrieron al impostor. ¬°Muy bien!' : 'El impostor se les escap√≥...';
  document.getElementById('win-reveal').innerHTML = `
    <div style="margin-bottom:12px;">
      <span style="color:var(--muted);font-size:0.85rem;">LA PALABRA ERA</span><br>
      <span style="color:var(--accent2);font-family:'Fredoka One',cursive;font-size:1.4rem;">${state.gameConfig.word}</span>
    </div>
    <div style="color:var(--muted);font-size:0.8rem;margin-bottom:10px;font-weight:700;">EL/LOS IMPOSTOR/ES</div>
    <div style="display:flex;gap:20px;justify-content:center;flex-wrap:wrap;">${impostorCards}</div>
  `;

  showScreen('win');
  if (winner === 'players') { sfxWin(); launchConfetti(); }
  else sfxImpostorWins();
}

function launchConfetti() {
  const colors = ['#ff6b6b','#ffd93d','#6bcb77','#4d96ff','#c77dff'];
  for (let i = 0; i < 60; i++) {
    setTimeout(() => {
      const el = document.createElement('div');
      el.className = 'confetti-item';
      el.style.left = Math.random() * 100 + 'vw';
      el.style.background = pickRandom(colors);
      el.style.animationDuration = (2 + Math.random() * 2) + 's';
      el.style.animationDelay = Math.random() * 0.5 + 's';
      el.style.width = el.style.height = (6 + Math.random() * 8) + 'px';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 4000);
    }, i * 40);
  }
}

async function backToLobby() {
  if (state.isHost) {
    const roomData = await loadRoom();
    if (roomData) {
      Object.keys(roomData.players).forEach(id => roomData.players[id].eliminated = false);
      // In solo mode, restore bots if they were eliminated
      if (state.roomCode === 'TEST') {
        const BOT_NAMES = ['Ana', 'Luis', 'Caro', 'Facu', 'Sofi'];
        const BOT_AVATARS = ['ü¶ä', 'üêº', 'ü¶Å', 'üêØ', 'üê∏'];
        for (let i = 0; i < 5; i++) {
          const key = `bot${i+1}`;
          if (roomData.players[key]) {
            roomData.players[key].eliminated = false;
          }
        }
      }
      roomData.phase = 'lobby';
      roomData.game = null;
      roomData.clues = {};
      roomData.votes = {};
      roomData.ready = {};
      roomData.typing = {};
      roomData.tiebreakPlayers = null;
      roomData.tiebreakRound = 0;
      roomData.round = 1;
      roomData.eliminatedCount = 0;
      await saveRoom(roomData);
    }
  }
  // Full state reset ‚Äî prevents instant role skip on second game
  state.clues = {};
  state.votes = {};
  state.gameConfig = null;
  state.myRole = null;
  goingToClue = false;
  if (readyTimerInterval) { clearInterval(readyTimerInterval); readyTimerInterval = null; }
  if (state.timerInterval) { clearInterval(state.timerInterval); state.timerInterval = null; }
  if (state.voteTimerInterval) { clearInterval(state.voteTimerInterval); state.voteTimerInterval = null; }
  Object.keys(botTypingState).forEach(k => delete botTypingState[k]);
  showScreen('lobby');
  // Restore sala name in lobby header
  const salaTitleElBack = document.getElementById('lobby-sala-name');
  if (salaTitleElBack) {
    const sn = state.salaName || '';
    const isReal = sn && sn !== state.roomCode && sn !== 'TEST';
    salaTitleElBack.textContent = isReal ? sn : 'Sala de espera';
  }
  const btnVote = document.getElementById('btn-vote');
  if (btnVote) { btnVote.style.display = 'block'; btnVote.disabled = true; }
  const voteWait = document.getElementById('vote-waiting');
  if (voteWait) voteWait.style.display = 'none';
  startPolling(pollLobby, 2000);
}

// ==================== BACKGROUND CANVAS ANIMATION ====================
(function() {
  const canvas = document.getElementById('bg-canvas');
  const ctx = canvas.getContext('2d');

  let W, H, particles, connections;
  const COLORS = ['#c77dff','#4d96ff','#ff6b6b','#ffd93d','#6bcb77'];
  const NUM_PARTICLES = 55;

  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  }

  function Particle() {
    this.reset = function() {
      this.x = Math.random() * W;
      this.y = Math.random() * H;
      this.vx = (Math.random() - 0.5) * 0.4;
      this.vy = (Math.random() - 0.5) * 0.4;
      this.r = Math.random() * 2.5 + 1;
      this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
      this.alpha = Math.random() * 0.4 + 0.15;
      this.pulseSpeed = Math.random() * 0.02 + 0.008;
      this.pulseOffset = Math.random() * Math.PI * 2;
    };
    this.reset();

    this.update = function(t) {
      this.x += this.vx;
      this.y += this.vy;
      if (this.x < -10) this.x = W + 10;
      if (this.x > W + 10) this.x = -10;
      if (this.y < -10) this.y = H + 10;
      if (this.y > H + 10) this.y = -10;
      this.currentAlpha = this.alpha * (0.7 + 0.3 * Math.sin(t * this.pulseSpeed + this.pulseOffset));
    };

    this.draw = function() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.globalAlpha = this.currentAlpha;
      ctx.fill();
    };
  }

  function init() {
    resize();
    particles = Array.from({ length: NUM_PARTICLES }, () => new Particle());
  }

  let t = 0;
  function draw() {
    ctx.clearRect(0, 0, W, H);
    t++;

    // Draw connections between nearby particles
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const dx = particles[i].x - particles[j].x;
        const dy = particles[i].y - particles[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 120) {
          ctx.beginPath();
          ctx.moveTo(particles[i].x, particles[i].y);
          ctx.lineTo(particles[j].x, particles[j].y);
          ctx.strokeStyle = particles[i].color;
          ctx.globalAlpha = (1 - dist / 120) * 0.08;
          ctx.lineWidth = 0.8;
          ctx.stroke();
        }
      }
    }

    // Draw particles
    particles.forEach(p => {
      p.update(t);
      p.draw();
    });

    ctx.globalAlpha = 1;
    requestAnimationFrame(draw);
  }

  window.addEventListener('resize', resize);
  init();
  draw();
})();

// ==================== KICK OFF ====================
function dismissSplash() {
  const splash = document.getElementById('splash');
  splash.classList.add('hiding');
  setTimeout(() => { splash.style.display = 'none'; }, 500);

  // Start YouTube music immediately on splash click (browser allows autoplay after interaction)
  if (!musicStarted) {
    musicStarted = true;
    musicCurrentIndex = Math.floor(Math.random() * YT_VIDEOS.length);
    musicLoad(musicCurrentIndex, true);
  }

  // Also unlock Web Audio for sfx
  try { getAudioCtx().resume(); } catch(e) {}
}

// ==================== AVATAR CREATOR SYSTEM ====================

const SKIN_COLORS = ['#FFDBB4','#F1C27D','#E0AC69','#C68642','#8D5524','#FFCBA4','#FFE0BD','#F9D5A7','#D4956A','#A0522D'];
const EYE_TYPES = [
  { id:'normal', label:'Normal', path: '<ellipse cx="36" cy="48" rx="5" ry="6" fill="{ec}"/><ellipse cx="64" cy="48" rx="5" ry="6" fill="{ec}"/><circle cx="37" cy="47" r="2" fill="#fff" opacity="0.8"/><circle cx="65" cy="47" r="2" fill="#fff" opacity="0.8"/>' },
  { id:'happy', label:'Feliz', path: '<path d="M31 48 Q36 54 41 48" stroke="{ec}" stroke-width="2.5" fill="none" stroke-linecap="round"/><path d="M59 48 Q64 54 69 48" stroke="{ec}" stroke-width="2.5" fill="none" stroke-linecap="round"/>' },
  { id:'cool', label:'Cool', path: '<ellipse cx="36" cy="48" rx="6" ry="5" fill="{ec}"/><ellipse cx="64" cy="48" rx="6" ry="5" fill="{ec}"/><line x1="30" y1="44" x2="42" y2="43" stroke="{ec}" stroke-width="2.5" stroke-linecap="round"/><line x1="58" y1="43" x2="70" y2="44" stroke="{ec}" stroke-width="2.5" stroke-linecap="round"/>' },
  { id:'angry', label:'Enojado', path: '<ellipse cx="36" cy="49" rx="5" ry="5.5" fill="{ec}"/><ellipse cx="64" cy="49" rx="5" ry="5.5" fill="{ec}"/><line x1="30" y1="43" x2="42" y2="45" stroke="{ec}" stroke-width="3" stroke-linecap="round"/><line x1="58" y1="45" x2="70" y2="43" stroke="{ec}" stroke-width="3" stroke-linecap="round"/>' },
  { id:'wink', label:'Gui√±o', path: '<ellipse cx="36" cy="48" rx="5" ry="6" fill="{ec}"/><circle cx="37" cy="47" r="2" fill="#fff" opacity="0.8"/><path d="M59 48 Q64 54 69 48" stroke="{ec}" stroke-width="2.5" fill="none" stroke-linecap="round"/>' },
  { id:'star', label:'Estrella', path: '<text x="31" y="54" font-size="11" fill="{ec}">‚òÖ</text><text x="59" y="54" font-size="11" fill="{ec}">‚òÖ</text>' },
];
const EYE_COLORS = ['#1a1a2e','#3d2b1f','#1b4332','#1e3a5f','#6b2d8b','#c62828','#1565c0','#00695c'];

const HAIR_STYLES = [
  { id:'none', label:'Ninguno', svg: '' },
  { id:'short', label:'Corto', svg: '<ellipse cx="50" cy="22" rx="28" ry="14" fill="{hc}"/><rect x="22" y="22" width="56" height="8" fill="{hc}" rx="2"/>' },
  { id:'long', label:'Largo', svg: '<ellipse cx="50" cy="22" rx="28" ry="14" fill="{hc}"/><rect x="22" y="22" width="8" height="30" fill="{hc}" rx="4"/><rect x="70" y="22" width="8" height="30" fill="{hc}" rx="4"/>' },
  { id:'curly', label:'Rizado', svg: '<ellipse cx="50" cy="20" rx="28" ry="15" fill="{hc}"/><circle cx="26" cy="28" r="8" fill="{hc}"/><circle cx="74" cy="28" r="8" fill="{hc}"/><circle cx="35" cy="15" r="7" fill="{hc}"/><circle cx="65" cy="15" r="7" fill="{hc}"/><circle cx="50" cy="11" r="8" fill="{hc}"/>' },
  { id:'spiky', label:'Punta', svg: '<polygon points="50,4 56,18 62,6 65,20 72,8 70,24 78,18 72,28 22,28 28,18 22,8 30,20 37,6 44,18" fill="{hc}"/>' },
  { id:'bun', label:'Mo√±o', svg: '<ellipse cx="50" cy="25" rx="26" ry="12" fill="{hc}"/><circle cx="50" cy="12" r="11" fill="{hc}"/><circle cx="50" cy="10" r="7" fill="{hc}" opacity="0.6"/>' },
  { id:'cap', label:'Gorra', svg: '<ellipse cx="50" cy="24" rx="28" ry="12" fill="{hc}"/><rect x="22" y="24" width="56" height="6" fill="{hc}" rx="2"/><rect x="14" y="28" width="72" height="6" fill="{hc}" rx="3"/><rect x="38" y="14" width="24" height="6" fill="{hc}" opacity="0.6" rx="3"/>' },
  { id:'mohawk', label:'Mohawk', svg: '<ellipse cx="50" cy="26" rx="28" ry="12" fill="{hc}"/><rect x="44" y="4" width="12" height="24" fill="{hc}" rx="6"/>' },
];
const HAIR_COLORS = ['#1a1a1a','#5c3317','#d4a017','#c0392b','#8b4513','#f5f5f5','#ff69b4','#6a0dad','#228b22','#4169e1'];

const ACCESSORIES = [
  { id:'none', label:'Ninguno', svg: '' },
  { id:'glasses', label:'Anteojos', svg: '<circle cx="36" cy="52" r="9" fill="none" stroke="#333" stroke-width="2.5"/><circle cx="64" cy="52" r="9" fill="none" stroke="#333" stroke-width="2.5"/><line x1="45" y1="52" x2="55" y2="52" stroke="#333" stroke-width="2.5"/><line x1="27" y1="52" x2="22" y2="54" stroke="#333" stroke-width="2"/><line x1="73" y1="52" x2="78" y2="54" stroke="#333" stroke-width="2"/>' },
  { id:'sunglass', label:'Sol', svg: '<rect x="27" y="46" width="18" height="12" rx="5" fill="#111" opacity="0.85"/><rect x="55" y="46" width="18" height="12" rx="5" fill="#111" opacity="0.85"/><line x1="45" y1="52" x2="55" y2="52" stroke="#444" stroke-width="2"/><line x1="27" y1="52" x2="22" y2="54" stroke="#444" stroke-width="2"/><line x1="73" y1="52" x2="78" y2="54" stroke="#444" stroke-width="2"/>' },
  { id:'mask', label:'Mascarita', svg: '<rect x="28" y="62" width="44" height="20" rx="8" fill="#f0f0f0" stroke="#ccc" stroke-width="1.5"/><line x1="32" y1="69" x2="68" y2="69" stroke="#ddd" stroke-width="1.5"/><line x1="32" y1="74" x2="68" y2="74" stroke="#ddd" stroke-width="1.5"/>' },
  { id:'bandana', label:'Pa√±uelo', svg: '<path d="M28 62 Q50 72 72 62 Q70 78 50 80 Q30 78 28 62Z" fill="#c0392b" opacity="0.9"/><circle cx="50" cy="63" r="2" fill="#e74c3c"/>' },
  { id:'monocle', label:'Mon√≥culo', svg: '<circle cx="64" cy="52" r="10" fill="none" stroke="#b8860b" stroke-width="2.5"/><line x1="74" y1="56" x2="76" y2="66" stroke="#b8860b" stroke-width="2"/>' },
  { id:'scar', label:'Cicatriz', svg: '<path d="M38 44 L42 56" stroke="#c0392b" stroke-width="2" stroke-linecap="round"/><path d="M40 44 L44 56" stroke="#c0392b" stroke-width="1.5" stroke-linecap="round" opacity="0.5"/>' },
  { id:'freckles', label:'Pecas', svg: '<circle cx="33" cy="58" r="2" fill="#c68642" opacity="0.7"/><circle cx="39" cy="61" r="1.5" fill="#c68642" opacity="0.7"/><circle cx="29" cy="61" r="1.5" fill="#c68642" opacity="0.7"/><circle cx="61" cy="58" r="2" fill="#c68642" opacity="0.7"/><circle cx="67" cy="61" r="1.5" fill="#c68642" opacity="0.7"/><circle cx="71" cy="61" r="1.5" fill="#c68642" opacity="0.7"/>' },
];

const OUTFITS = [
  { id:'basic', label:'B√°sico', svg: '<rect x="22" y="90" width="56" height="30" rx="8" fill="{oc}"/>' },
  { id:'tshirt', label:'Remera', svg: '<rect x="22" y="90" width="56" height="30" rx="8" fill="{oc}"/><polygon points="22,90 36,98 50,92 64,98 78,90 74,90 64,96 50,90 36,96 26,90" fill="{oc}" opacity="0.7"/>' },
  { id:'suit', label:'Traje', svg: '<rect x="22" y="90" width="56" height="30" rx="8" fill="#1a1a2e"/><rect x="44" y="90" width="12" height="30" fill="{oc}"/><polygon points="50,90 42,102 50,98 58,102" fill="#c0392b"/><rect x="46" y="92" width="8" height="4" rx="1" fill="#fff" opacity="0.6"/>' },
  { id:'hoodie', label:'Buzo', svg: '<rect x="22" y="90" width="56" height="30" rx="8" fill="{oc}"/><path d="M35 90 Q50 100 65 90" stroke="{oc}" stroke-width="3" fill="none" opacity="0.5"/><ellipse cx="50" cy="92" rx="8" ry="5" fill="{oc}" opacity="0.6"/>' },
  { id:'dress', label:'Vestido', svg: '<path d="M30 90 Q50 86 70 90 L78 120 L22 120Z" fill="{oc}" rx="4"/><line x1="40" y1="90" x2="36" y2="120" stroke="{oc}" stroke-width="1" opacity="0.4"/><line x1="60" y1="90" x2="64" y2="120" stroke="{oc}" stroke-width="1" opacity="0.4"/>' },
  { id:'stripes', label:'Rayas', svg: '<rect x="22" y="90" width="56" height="30" rx="8" fill="{oc}"/><rect x="22" y="96" width="56" height="5" fill="#fff" opacity="0.2"/><rect x="22" y="106" width="56" height="5" fill="#fff" opacity="0.2"/><rect x="22" y="116" width="56" height="4" fill="#fff" opacity="0.2"/>' },
  { id:'ninja', label:'Ninja', svg: '<rect x="22" y="90" width="56" height="30" rx="8" fill="#1a1a1a"/><rect x="22" y="90" width="56" height="8" fill="{oc}" opacity="0.8"/>' },
];
const OUTFIT_COLORS = ['#c0392b','#2980b9','#27ae60','#8e44ad','#e67e22','#1abc9c','#2c3e50','#f39c12','#e91e63','#00bcd4'];

// Current avatar config
let avatarConfig = {
  skin: '#F1C27D',
  eyeType: 'normal',
  eyeColor: '#1a1a2e',
  hairStyle: 'short',
  hairColor: '#5c3317',
  accessory: 'none',
  outfitStyle: 'tshirt',
  outfitColor: '#2980b9',
};
let currentTab = 'skin';

function loadSavedAvatar() {
  try {
    const saved = localStorage.getItem('impostor_avatar');
    if (saved) avatarConfig = { ...avatarConfig, ...JSON.parse(saved) };
  } catch(e) {}
}

function saveAvatarToStorage() {
  try {
    localStorage.setItem('impostor_avatar', JSON.stringify(avatarConfig));
  } catch(e) {}
}

function buildAvatarSVG(cfg) {
  const skin = cfg.skin || '#F1C27D';
  const eyeSvg = (EYE_TYPES.find(e => e.id === cfg.eyeType) || EYE_TYPES[0]).path.replaceAll('{ec}', cfg.eyeColor || '#1a1a2e');
  const hairObj = HAIR_STYLES.find(h => h.id === cfg.hairStyle) || HAIR_STYLES[1];
  const hairSvg = hairObj.svg.replaceAll('{hc}', cfg.hairColor || '#5c3317');
  const accObj = ACCESSORIES.find(a => a.id === cfg.accessory) || ACCESSORIES[0];
  const accSvg = accObj.svg;
  const outfitObj = OUTFITS.find(o => o.id === cfg.outfitStyle) || OUTFITS[0];
  const outfitSvg = outfitObj.svg.replaceAll('{oc}', cfg.outfitColor || '#2980b9');
  // Shadow highlight on face
  const cheekL = `<ellipse cx="30" cy="60" rx="7" ry="5" fill="#ff9999" opacity="0.25"/>`;
  const cheekR = `<ellipse cx="70" cy="60" rx="7" ry="5" fill="#ff9999" opacity="0.25"/>`;
  // Mouth
  const mouth = `<path d="M40 68 Q50 76 60 68" stroke="#c0736a" stroke-width="2.5" fill="none" stroke-linecap="round"/>`;
  return `
    ${outfitSvg}
    <ellipse cx="50" cy="52" rx="28" ry="30" fill="${skin}"/>
    ${hairSvg}
    ${eyeSvg}
    ${cheekL}${cheekR}
    ${mouth}
    ${accSvg}
  `;
}

function renderAvatarPreview() {
  const svg = document.getElementById('avatar-preview-svg');
  if (svg) svg.innerHTML = buildAvatarSVG(avatarConfig);
  // No URL sharing needed - avatar is embedded in player data in the room
  // Update name preview from avatar screen name field
  const nameEl = document.getElementById('avatar-name-preview');
  const avatarNameInput = document.getElementById('avatar-username');
  const inputName = document.getElementById('input-name');
  const displayName = (avatarNameInput && avatarNameInput.value.trim()) 
    || (inputName && inputName.value.trim()) 
    || 'Tu personaje';
  if (nameEl) nameEl.textContent = displayName;
}

function getAvatarSVGString() {
  return '<svg viewBox="0 0 100 120" xmlns="http://www.w3.org/2000/svg">' + buildAvatarSVG(avatarConfig) + '</svg>';
}

function switchTab(tab) {
  currentTab = tab;
  document.querySelectorAll('.avatar-tab').forEach(t => t.classList.remove('active'));
  document.getElementById('tab-' + tab).classList.add('active');
  renderTabOptions();
}

function renderTabOptions() {
  const panel = document.getElementById('avatar-options-panel');
  if (!panel) return;

  if (currentTab === 'skin') {
    panel.innerHTML = `<div style="font-size:0.8rem; color:var(--muted); margin-bottom:8px; font-weight:700;">COLOR DE PIEL</div>
      <div class="colors-row">${SKIN_COLORS.map(c => `<div class="color-opt${avatarConfig.skin===c?' selected':''}" style="background:${c}" onclick="setAvatar('skin','${c}')"></div>`).join('')}</div>`;
  }
  else if (currentTab === 'eyes') {
    panel.innerHTML = `<div style="font-size:0.8rem; color:var(--muted); margin-bottom:8px; font-weight:700;">FORMA DE OJOS</div>
      <div class="avatar-options-grid">${EYE_TYPES.map(e => `<div class="avatar-opt${avatarConfig.eyeType===e.id?' selected':''}" onclick="setAvatar('eyeType','${e.id}')" title="${e.label}">
        <svg viewBox="0 0 100 30" width="36" height="20" xmlns="http://www.w3.org/2000/svg">${e.path.replaceAll('{ec}','#1a1a2e').replace(/cy="48"/g,'cy="18"').replace(/cy="47"/g,'cy="17"').replace(/cy="49"/g,'cy="19"').replace(/cy="52"/g,'cy="22"').replace(/cy="54"/g,'cy="24"').replace(/cy="44"/g,'cy="14"').replace(/cy="43"/g,'cy="13"').replace(/cy="45"/g,'cy="15"').replace(/cy="46"/g,'cy="16"')}</svg>
      </div>`).join('')}</div>
      <div style="font-size:0.8rem; color:var(--muted); margin-bottom:8px; font-weight:700;">COLOR</div>
      <div class="colors-row">${EYE_COLORS.map(c => `<div class="color-opt${avatarConfig.eyeColor===c?' selected':''}" style="background:${c}" onclick="setAvatar('eyeColor','${c}')"></div>`).join('')}</div>`;
  }
  else if (currentTab === 'hair') {
    panel.innerHTML = `<div style="font-size:0.8rem; color:var(--muted); margin-bottom:8px; font-weight:700;">ESTILO</div>
      <div class="avatar-options-grid">${HAIR_STYLES.map(h => `<div class="avatar-opt${avatarConfig.hairStyle===h.id?' selected':''}" onclick="setAvatar('hairStyle','${h.id}')" title="${h.label}">
        ${h.id==='none'?'üö´':`<svg viewBox="0 0 100 40" width="40" height="20" xmlns="http://www.w3.org/2000/svg">${h.svg.replaceAll('{hc}',avatarConfig.hairColor)}</svg>`}
      </div>`).join('')}</div>
      <div style="font-size:0.8rem; color:var(--muted); margin-bottom:8px; font-weight:700;">COLOR</div>
      <div class="colors-row">${HAIR_COLORS.map(c => `<div class="color-opt${avatarConfig.hairColor===c?' selected':''}" style="background:${c}; border:1px solid rgba(255,255,255,0.2);" onclick="setAvatar('hairColor','${c}')"></div>`).join('')}</div>`;
  }
  else if (currentTab === 'accessory') {
    panel.innerHTML = `<div style="font-size:0.8rem; color:var(--muted); margin-bottom:8px; font-weight:700;">ACCESORIO</div>
      <div class="avatar-options-grid">${ACCESSORIES.map(a => `<div class="avatar-opt${avatarConfig.accessory===a.id?' selected':''}" onclick="setAvatar('accessory','${a.id}')" title="${a.label}">
        ${a.id==='none'?'üö´':`<svg viewBox="25 40 50 45" width="38" height="28" xmlns="http://www.w3.org/2000/svg">${a.svg}</svg>`}
      </div>`).join('')}</div>`;
  }
  else if (currentTab === 'outfit') {
    panel.innerHTML = `<div style="font-size:0.8rem; color:var(--muted); margin-bottom:8px; font-weight:700;">ESTILO DE ROPA</div>
      <div class="avatar-options-grid">${OUTFITS.map(o => `<div class="avatar-opt${avatarConfig.outfitStyle===o.id?' selected':''}" onclick="setAvatar('outfitStyle','${o.id}')" title="${o.label}">
        <svg viewBox="20 85 60 35" width="40" height="22" xmlns="http://www.w3.org/2000/svg">${o.svg.replaceAll('{oc}',avatarConfig.outfitColor)}</svg>
      </div>`).join('')}</div>
      <div style="font-size:0.8rem; color:var(--muted); margin-bottom:8px; font-weight:700;">COLOR</div>
      <div class="colors-row">${OUTFIT_COLORS.map(c => `<div class="color-opt${avatarConfig.outfitColor===c?' selected':''}" style="background:${c}" onclick="setAvatar('outfitColor','${c}')"></div>`).join('')}</div>`;
  }
}

function setAvatar(key, val) {
  avatarConfig[key] = val;
  renderAvatarPreview();
  renderTabOptions();
}

function copyAvatarLink() {
  const input = document.getElementById('avatar-share-url');
  if (!input || !input.value) return;
  navigator.clipboard.writeText(input.value).then(() => {
    const btn = event.target;
    const orig = btn.textContent;
    btn.textContent = '‚úÖ Copiado!';
    setTimeout(() => btn.textContent = orig, 1500);
  }).catch(() => {
    input.select(); document.execCommand('copy');
  });
}

function loadAvatarFromCode() {
  const input = document.getElementById('avatar-load-code');
  if (!input || !input.value.trim()) return;
  try {
    const parsed = JSON.parse(atob(input.value.trim()));
    avatarConfig = { ...avatarConfig, ...parsed };
    saveAvatarToStorage();
    renderAvatarPreview();
    renderTabOptions();
    input.value = '';
    input.placeholder = '‚úÖ Personaje cargado!';
    setTimeout(() => input.placeholder = 'Peg√° el c√≥digo de tu amigo ac√°...', 2000);
  } catch(e) {
    input.placeholder = '‚ùå C√≥digo inv√°lido, revisalo';
    setTimeout(() => input.placeholder = 'Peg√° el c√≥digo de tu amigo ac√°...', 2000);
  }
}

function saveAndGoHome() {
  // Save username to localStorage only ‚Äî do NOT touch sala name field
  const avatarName = document.getElementById('avatar-username').value.trim();
  if (avatarName) {
    localStorage.setItem('impostor_username', avatarName);
  }
  saveAvatarToStorage();
  showScreen('home');
}

function openAvatarCreator() {
  loadSavedAvatar();
  // Load saved username into avatar screen field
  const savedName = localStorage.getItem('impostor_username') || document.getElementById('input-name').value.trim();
  const avatarNameInput = document.getElementById('avatar-username');
  if (avatarNameInput) avatarNameInput.value = savedName;
  renderAvatarPreview();
  renderTabOptions();
  showScreen('avatar');
}

// Load avatar config on startup ‚Äî do NOT pre-fill sala name with username
window.addEventListener('load', () => {
  loadSavedAvatar();
  // Sala name field stays empty ‚Äî player identity comes from avatar creator
});

function getPlayerAvatar() {
  // Returns SVG string if custom avatar exists, else random emoji
  try {
    const saved = localStorage.getItem('impostor_avatar');
    if (saved) return getAvatarSVGString();
  } catch(e) {}
  return pickRandom(AVATARS);
}

// ==================== MENU MUSIC ====================
const YT_VIDEOS = ["lRrOLTHu-ew","PyGev5cKTlQ","7uBqNgxAuBA","LuGAWR2eRyQ","oYwL-FzFDKQ","YagdayNkfho","pk8tCJ_CvGU","U0TXIXTzJEY","qlaRFRA4qFU"];
let musicCurrentIndex = -1;
let musicIsPlaying = false;
let musicStarted = false;

function musicLoad(index, autoplay) {
  musicCurrentIndex = index;
  const iframe = document.getElementById('yt-iframe');
  if (!iframe) return;
  const vid = YT_VIDEOS[index];
  iframe.src = '';
  setTimeout(() => {
    iframe.src = 'https://www.youtube.com/embed/' + vid + '?autoplay=' + (autoplay?1:0) + '&mute=0&controls=0&modestbranding=1&rel=0';
    musicIsPlaying = autoplay;
    musicUpdateUI();
  }, 80);
}

function musicUpdateUI() {
  const btn = document.getElementById('music-play-btn');
  const title = document.getElementById('music-title');
  if (btn) btn.textContent = musicIsPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
  if (title) title.textContent = musicIsPlaying ? 'üéµ Sonando...' : 'üéµ M√∫sica';
}

function toggleMusic() {
  if (!musicStarted) {
    musicStarted = true;
    musicCurrentIndex = Math.floor(Math.random() * YT_VIDEOS.length);
    musicLoad(musicCurrentIndex, true);
    return;
  }
  if (musicIsPlaying) {
    const iframe = document.getElementById('yt-iframe');
    if (iframe) iframe.src = '';
    musicIsPlaying = false;
    musicUpdateUI();
  } else {
    musicLoad(musicCurrentIndex, true);
  }
}

function randomSong() {
  musicStarted = true;
  let next = musicCurrentIndex;
  while (next === musicCurrentIndex && YT_VIDEOS.length > 1) {
    next = Math.floor(Math.random() * YT_VIDEOS.length);
  }
  musicLoad(next, true);
}

function setMusicVolume(val) {
  const iframe = document.getElementById('yt-iframe');
  if (!iframe || !iframe.contentWindow) return;
  try {
    iframe.contentWindow.postMessage(JSON.stringify({event:'command',func:'setVolume',args:[parseInt(val)]}), '*');
  } catch(e) {}
}

function stopMenuMusic() {
  const iframe = document.getElementById('yt-iframe');
  if (iframe) iframe.src = '';
  musicIsPlaying = false;
  const bar = document.getElementById('music-bar');
  if (bar) bar.style.display = 'none';
}

// Music starts on splash dismiss (see dismissSplash)

</script>
</body>
</html>
